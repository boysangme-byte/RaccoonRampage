<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü¶ù Raccoon Rampage</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', sans-serif;
    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
    overflow: hidden;
    color: #fff;
    user-select: none;
}

#gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
}

#gameCanvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: none;
}

/* HUD */
#hud {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
}

/* ÌÅ¨Î°úÏä§Ìó§Ïñ¥ - ÌååÏä§ÌÖî Î≥Ñ */
#crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}

#crosshair .star {
    font-size: 30px;
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.1); opacity: 1; }
}

/* ÏÉÅÎã® HUD */
#topHUD {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
}

#stageTitle {
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    background: rgba(255, 182, 193, 0.8);
    padding: 10px 30px;
    border-radius: 20px;
    border: 3px solid #fff;
    animation: slideDown 0.5s ease-out;
}

@keyframes slideDown {
    from {
        transform: translateY(-100px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* ÌïòÎã® HUD */
#bottomHUD {
    position: absolute;
    bottom: 20px;
    left: 20px;
    right: 20px;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    gap: 20px;
}

#healthBar, #sugarMeter {
    flex: 1;
    min-width: 200px;
}

.label {
    font-size: 14px;
    margin-bottom: 5px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.bar-container {
    position: relative;
    background: rgba(0, 0, 0, 0.5);
    border: 3px solid #fff;
    border-radius: 15px;
    height: 40px;
    overflow: hidden;
}

.bar {
    height: 100%;
    transition: width 0.3s ease;
    border-radius: 12px;
}

#healthBarFill {
    background: linear-gradient(90deg, #ff69b4 0%, #ff1493 100%);
    box-shadow: 0 0 20px rgba(255, 20, 147, 0.6);
}

#sugarBarFill {
    background: linear-gradient(90deg, #ffd700 0%, #ff69b4 50%, #ff1493 100%);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
}

.bar-container span {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: bold;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

#ammoDisplay {
    text-align: center;
    background: rgba(255, 182, 193, 0.8);
    padding: 15px 25px;
    border-radius: 15px;
    border: 3px solid #fff;
    min-width: 180px;
}

.weapon-name {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 5px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.ammo-count {
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

/* ÏÉÅÌò∏ÏûëÏö© ÌîÑÎ°¨ÌîÑÌä∏ */
#interactionPrompt {
    position: absolute;
    top: 60%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 182, 193, 0.9);
    padding: 15px 30px;
    border-radius: 20px;
    border: 3px solid #fff;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    animation: bounce 1s ease-in-out infinite;
}

@keyframes bounce {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
}

/* Îã§Ïù¥ÏñºÎ°úÍ∑∏ Î∞ïÏä§ */
#dialogueBox {
    position: absolute;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 182, 193, 0.95);
    padding: 30px;
    border-radius: 20px;
    border: 4px solid #fff;
    max-width: 600px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
}

#dialogueText {
    font-size: 18px;
    line-height: 1.6;
    margin-bottom: 15px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}

#dialogueContinue {
    text-align: center;
    font-size: 14px;
    color: #666;
    font-style: italic;
}

/* Î°úÎî© ÌôîÎ©¥ */
#loadingScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
}

#loadingScreen h1 {
    font-size: 48px;
    margin-bottom: 30px;
    text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
}

.loading-bar {
    width: 400px;
    height: 30px;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 15px;
    overflow: hidden;
    border: 3px solid #fff;
    margin-bottom: 20px;
}

#loadingProgress {
    height: 100%;
    background: linear-gradient(90deg, #ff69b4 0%, #ff1493 100%);
    width: 0%;
    transition: width 0.3s ease;
}

/* Î©îÏù∏ Î©îÎâ¥ */
#mainMenu {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 50;
}

#mainMenu h1 {
    font-size: 64px;
    margin-bottom: 50px;
    text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
}

#mainMenu button {
    background: rgba(255, 182, 193, 0.9);
    border: 4px solid #fff;
    color: #fff;
    padding: 15px 40px;
    font-size: 24px;
    font-weight: bold;
    border-radius: 25px;
    cursor: pointer;
    margin: 10px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    pointer-events: auto;
}

#mainMenu button:hover {
    transform: scale(1.1);
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

/* Ïò§Î≤ÑÎ†àÏù¥ Ìö®Í≥º */
#lowHealthVignette {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, transparent 30%, rgba(255, 20, 147, 0.3) 100%);
    pointer-events: none;
    z-index: 5;
    animation: pulseVignette 2s ease-in-out infinite;
}

@keyframes pulseVignette {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
}

#sugarRushOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, 
        rgba(255, 0, 150, 0.2) 0%,
        rgba(255, 100, 0, 0.2) 25%,
        rgba(255, 200, 0, 0.2) 50%,
        rgba(0, 255, 150, 0.2) 75%,
        rgba(150, 0, 255, 0.2) 100%);
    background-size: 400% 400%;
    pointer-events: none;
    z-index: 5;
    animation: rainbowFlow 3s linear infinite;
    mix-blend-mode: screen;
}

@keyframes rainbowFlow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.hidden {
    display: none !important;
}

/* Î∞òÏùëÌòï */
@media (max-width: 768px) {
    #bottomHUD {
        flex-direction: column;
        align-items: center;
    }
    
    #healthBar, #sugarMeter, #ammoDisplay {
        width: 100%;
        max-width: 300px;
    }
}

/* ÌîåÎ°úÌåÖ Îç∞ÎØ∏ÏßÄ Ïà´Ïûê */
.floating-damage {
    position: absolute;
    font-size: 24px;
    font-weight: bold;
    color: #ff0000;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    pointer-events: none;
    z-index: 1001;
    animation: floatUp 1s ease-out forwards;
}

.floating-damage.headshot {
    color: #ffd700;
    font-size: 32px;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
}

@keyframes floatUp {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-100px) scale(1.5);
    }
}

/* ÌûàÌä∏ ÎßàÏª§ Ïï†ÎãàÎ©îÏù¥ÏÖò */
#hitMarker {
    animation: hitMarkerPulse 0.2s ease-out;
}

@keyframes hitMarkerPulse {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1.5);
    }
}

/* Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨ Ìö®Í≥º */
.shake {
    animation: shake 0.3s;
}

@keyframes shake {
    0%, 100% { transform: translateX(0) translateY(0); }
    10% { transform: translateX(-2px) translateY(-1px); }
    20% { transform: translateX(2px) translateY(1px); }
    30% { transform: translateX(-1px) translateY(2px); }
    40% { transform: translateX(1px) translateY(-2px); }
    50% { transform: translateX(-2px) translateY(1px); }
    60% { transform: translateX(2px) translateY(-1px); }
    70% { transform: translateX(-1px) translateY(-2px); }
    80% { transform: translateX(1px) translateY(2px); }
    90% { transform: translateX(-2px) translateY(-1px); }
}

/* ÏΩ§Î≥¥ Ìö®Í≥º */
.combo-effect {
    animation: comboPulse 0.5s ease-out;
}

@keyframes comboPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div id="hud">
            <!-- ÌÅ¨Î°úÏä§Ìó§Ïñ¥ -->
            <div id="crosshair">
                <div class="star">‚≠ê</div>
            </div>
            
            <!-- ÏÉÅÎã® Ï†ïÎ≥¥ -->
            <div id="topHUD">
                <div id="stageTitle"></div>
            </div>
            
            <!-- ÌïòÎã® HUD -->
            <div id="bottomHUD">
                <div id="healthBar">
                    <div class="label">üíñ Love Gauge</div>
                    <div class="bar-container">
                        <div class="bar" id="healthBarFill"></div>
                        <span id="healthText">100 / 100</span>
                    </div>
                </div>
                
                <div id="ammoDisplay">
                    <div class="weapon-name" id="weaponName">Acorn Blaster</div>
                    <div class="ammo-count" id="ammoCount">30 / 30</div>
                </div>
                
                <div id="sugarMeter">
                    <div class="label">üç≠ Sugar Rush</div>
                    <div class="bar-container">
                        <div class="bar" id="sugarBarFill"></div>
                        <span id="sugarText">0%</span>
                    </div>
                </div>
            </div>
            
            <!-- Ï†êÏàò ÌëúÏãú -->
            <div id="scoreDisplay" style="position: absolute; top: 20px; right: 20px; background: rgba(255, 182, 193, 0.8); padding: 15px 25px; border-radius: 15px; border: 3px solid #fff; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);">
                <div>Score: <span id="scoreValue">0</span></div>
                <div id="comboDisplay" style="font-size: 16px; margin-top: 5px; color: #ffd700; display: none;">Combo x<span id="comboValue">0</span>!</div>
            </div>
            
            <!-- Î≥¥Ïä§ Ï≤¥Î†•Î∞î -->
            <div id="bossHealthBar" class="hidden" style="position: absolute; top: 80px; left: 50%; transform: translateX(-50%); width: 600px; background: rgba(0, 0, 0, 0.7); border: 3px solid #ff0000; border-radius: 15px; padding: 10px;">
                <div style="text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 5px; color: #ff0000;">BOSS</div>
                <div style="background: rgba(255, 0, 0, 0.3); height: 30px; border-radius: 10px; overflow: hidden;">
                    <div id="bossHealthFill" style="background: linear-gradient(90deg, #ff0000 0%, #ff6666 100%); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
                <div id="bossHealthText" style="text-align: center; margin-top: 5px; font-weight: bold;">100%</div>
            </div>
            
            <!-- ÏÉÅÌò∏ÏûëÏö© UI -->
            <div id="interactionPrompt" class="hidden">Press E to interact</div>
            
            <!-- Îã§Ïù¥ÏñºÎ°úÍ∑∏ -->
            <div id="dialogueBox" class="hidden">
                <div id="dialogueText"></div>
                <div id="dialogueContinue">Press SPACE to continue</div>
            </div>
            
            <!-- ÌîåÎ°úÌåÖ Îç∞ÎØ∏ÏßÄ Ïà´Ïûê Ïª®ÌÖåÏù¥ÎÑà -->
            <div id="floatingDamageContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000;"></div>
            
            <!-- ÌûàÌä∏ ÎßàÏª§ -->
            <div id="hitMarker" class="hidden" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; pointer-events: none; z-index: 999;">
                <div style="position: absolute; width: 100%; height: 2px; background: #ff0000; top: 50%; left: 0; transform: translateY(-50%);"></div>
                <div style="position: absolute; height: 100%; width: 2px; background: #ff0000; left: 50%; top: 0; transform: translateX(-50%);"></div>
            </div>
            
            <!-- ÎØ∏ÎãàÎßµ -->
            <div id="minimap" style="position: absolute; top: 20px; left: 20px; width: 200px; height: 200px; background: rgba(0, 0, 0, 0.6); border: 3px solid #fff; border-radius: 10px; z-index: 100;">
                <canvas id="minimapCanvas" width="200" height="200" style="border-radius: 7px;"></canvas>
            </div>
            
            <!-- Ïõ®Ïù¥Î∏å Í∞Ñ ÏÉÅÏ†ê -->
            <div id="shopMenu" class="hidden" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); border: 5px solid #fff; border-radius: 20px; padding: 30px; z-index: 10000; min-width: 500px;">
                <h2 style="text-align: center; margin-bottom: 20px; font-size: 32px; color: #ffd700;">ÏÉÅÏ†ê</h2>
                <div id="shopItems" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <!-- ÏÉÅÏ†ê ÏïÑÏù¥ÌÖúÎì§ÏùÄ JavaScriptÎ°ú ÎèôÏ†Å ÏÉùÏÑ± -->
                </div>
                <button id="closeShop" style="margin-top: 20px; width: 100%; padding: 15px; font-size: 20px; background: #ff6b6b; color: white; border: none; border-radius: 10px; cursor: pointer;">Îã´Í∏∞</button>
            </div>
        </div>
        
        <!-- Î°úÎî© ÌôîÎ©¥ -->
        <div id="loadingScreen">
            <h1>ü¶ù Raccoon Rampage</h1>
            <div class="loading-bar">
                <div id="loadingProgress"></div>
            </div>
            <p>Loading...</p>
        </div>
        
        <!-- Î©îÏù∏ Î©îÎâ¥ -->
        <div id="mainMenu" class="hidden">
            <h1>ü¶ù Raccoon Rampage</h1>
            <button id="startButton">Start Game</button>
            <button id="instructionsButton">Instructions</button>
        </div>
        
        <!-- Ï†ÄÏÇ¨Ïñë Î™®Îìú Ïò§Î≤ÑÎ†àÏù¥ -->
        <div id="lowHealthVignette" class="hidden"></div>
        <div id="sugarRushOverlay" class="hidden"></div>
    </div>
    
    <!-- Î≤àÎì§Îêú Ïä§ÌÅ¨Î¶ΩÌä∏ -->
    <script>
// InputManager
class InputManager {
    constructor() {
        this.keys = {};
        this.mouse = {
            x: 0,
            y: 0,
            deltaX: 0,
            deltaY: 0,
            buttons: {},
            wheelDelta: 0
        };
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // keydown Ïù¥Î≤§Ìä∏ - Ìè¨Ïù∏ÌÑ∞ ÎùΩÍ≥º Î¨¥Í¥ÄÌïòÍ≤å Ìï≠ÏÉÅ ÏûëÎèô
        const keydownHandler = (e) => {
            // Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄÌïòÏßÄ ÏïäÏùå (Í≤åÏûÑ Ïª®Ìä∏Î°§Îßå)
            if (e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD' || 
                e.code === 'Space' || e.code === 'ShiftLeft') {
                // Í≤åÏûÑ Ïª®Ìä∏Î°§ ÌÇ§Îßå Ï≤òÎ¶¨
            }
            
            this.keys[e.code] = true;
            
            // Space ÌÇ§Îäî Ïó¨Îü¨ Î∞©ÏãùÏúºÎ°ú Í∞êÏßÄ
            if (e.code === 'Space' || e.key === ' ' || e.key === 'Space' || e.keyCode === 32) {
                this.keys['Space'] = true;
                this.keys[' '] = true;
            }
            // WASD ÌÇ§ Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏÑ§Ï†ï
            if (e.code === 'KeyW') {
                this.keys['KeyW'] = true;
                console.log('W key pressed');
            }
            if (e.code === 'KeyA') {
                this.keys['KeyA'] = true;
                console.log('A key pressed');
            }
            if (e.code === 'KeyS') {
                this.keys['KeyS'] = true;
                console.log('S key pressed');
            }
            if (e.code === 'KeyD') {
                this.keys['KeyD'] = true;
                console.log('D key pressed');
            }
        };
        
        const keyupHandler = (e) => {
            this.keys[e.code] = false;
            if (e.code === 'Space' || e.key === ' ' || e.key === 'Space' || e.keyCode === 32) {
                this.keys['Space'] = false;
                this.keys[' '] = false;
            }
            // WASD ÌÇ§ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ìï¥Ï†ú
            if (e.code === 'KeyW') this.keys['KeyW'] = false;
            if (e.code === 'KeyA') this.keys['KeyA'] = false;
            if (e.code === 'KeyS') this.keys['KeyS'] = false;
            if (e.code === 'KeyD') this.keys['KeyD'] = false;
        };
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù (capture Îã®Í≥ÑÏóêÏÑúÎèÑ ÏûëÎèôÌïòÎèÑÎ°ù)
        document.addEventListener('keydown', keydownHandler, true);
        document.addEventListener('keyup', keyupHandler, true);
        window.addEventListener('keydown', keydownHandler, true);
        window.addEventListener('keyup', keyupHandler, true);
        
        window.addEventListener('mousemove', (e) => {
            // Ìè¨Ïù∏ÌÑ∞ ÎùΩÏù¥ ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞ÏóêÎßå Îç∏ÌÉÄ ÏóÖÎç∞Ïù¥Ìä∏
            if (document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement) {
                this.mouse.deltaX = e.movementX || 0;
                this.mouse.deltaY = e.movementY || 0;
            } else {
                // Ìè¨Ïù∏ÌÑ∞ ÎùΩÏù¥ ÏóÜÏúºÎ©¥ Îç∏ÌÉÄÎ•º 0ÏúºÎ°ú ÏÑ§Ï†ï
                this.mouse.deltaX = 0;
                this.mouse.deltaY = 0;
            }
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
        });
        
        window.addEventListener('mousedown', (e) => {
            this.mouse.buttons[e.button] = true;
        });
        
        window.addEventListener('mouseup', (e) => {
            this.mouse.buttons[e.button] = false;
        });
        
        window.addEventListener('wheel', (e) => {
            this.mouse.wheelDelta = e.deltaY;
        });
    }
    
    isKeyPressed(code) {
        const result = this.keys[code] || false;
        return result;
    }
    
    isMouseButtonPressed(button) {
        return this.mouse.buttons[button] || false;
    }
    
    getMouseDelta() {
        const delta = {
            x: this.mouse.deltaX,
            y: this.mouse.deltaY
        };
        this.mouse.deltaX = 0;
        this.mouse.deltaY = 0;
        return delta;
    }
    
    lockPointer() {
        const canvas = document.getElementById('gameCanvas');
        canvas.requestPointerLock = canvas.requestPointerLock || 
                                   canvas.mozRequestPointerLock || 
                                   canvas.webkitRequestPointerLock;
        canvas.requestPointerLock();
    }
    
    unlockPointer() {
        document.exitPointerLock = document.exitPointerLock || 
                                  document.mozExitPointerLock || 
                                  document.webkitExitPointerLock;
        document.exitPointerLock();
    }
}

// WeaponBase
class WeaponBase {
    constructor(camera, scene, config) {
        this.camera = camera;
        this.scene = scene;
        
        this.name = config.name || 'Weapon';
        this.damage = config.damage || 10;
        this.fireRate = config.fireRate || 0.1;
        this.maxAmmo = config.maxAmmo || 30;
        this.currentAmmo = this.maxAmmo;
        this.reloadTime = config.reloadTime || 1.5;
        this.range = config.range || 100;
        
        this.lastFireTime = 0;
        this.isReloading = false;
    }
    
    update(deltaTime) {
    }
    
    shoot() {
        if (this.isReloading) return;
        if (Date.now() - this.lastFireTime < this.fireRate * 1000) return;
        if (this.currentAmmo <= 0) {
            this.reload();
            return;
        }
        
        this.performShoot();
        this.currentAmmo--;
        this.lastFireTime = Date.now();
    }
    
    performShoot() {
    }
    
    reload() {
        if (this.isReloading || this.currentAmmo >= this.maxAmmo) return;
        
        this.isReloading = true;
        setTimeout(() => {
            this.currentAmmo = this.maxAmmo;
            this.isReloading = false;
        }, this.reloadTime * 1000);
    }
}

// AcornBlaster
class AcornBlaster extends WeaponBase {
    constructor(camera, scene) {
        super(camera, scene, {
            name: 'Acorn Blaster',
            damage: 10,
            fireRate: 0.1,
            maxAmmo: 30,
            reloadTime: 1.5,
            range: 100
        });
        
        this.bulletSpeed = 50;
        this.spreadAngle = 0.02;
        this.bullets = [];
    }
    
    performShoot() {
        const direction = new THREE.Vector3();
        this.camera.getWorldDirection(direction);
        
        const spreadX = (Math.random() - 0.5) * this.spreadAngle;
        const spreadY = (Math.random() - 0.5) * this.spreadAngle;
        direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), spreadX);
        direction.applyAxisAngle(new THREE.Vector3(1, 0, 0), spreadY);
        
        this.createBullet(this.camera.position.clone(), direction);
        
        // Î∞úÏÇ¨ Ïãú Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨ (ÏïΩÍ∞Ñ)
        if (window.game && window.game.cameraShakeSystem) {
            window.game.cameraShakeSystem.shake(0.02, 0.1);
        }
    }
    
    createBullet(position, direction) {
        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
        const bullet = new THREE.Mesh(geometry, material);
        
        bullet.position.copy(position);
        this.scene.add(bullet);
        
        const startPos = position.clone();
        const velocity = direction.clone().multiplyScalar(this.bulletSpeed);
        
        const bulletData = {
            mesh: bullet,
            velocity: velocity,
            startPos: startPos,
            active: true,
            damage: this.damage
        };
        this.bullets.push(bulletData);
    }
    
    update(deltaTime) {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];
            if (!bullet.active) {
                this.bullets.splice(i, 1);
                continue;
            }
            
            bullet.mesh.position.add(bullet.velocity.clone().multiplyScalar(deltaTime));
            
            if (bullet.mesh.position.distanceTo(bullet.startPos) > this.range) {
                this.scene.remove(bullet.mesh);
                bullet.mesh.geometry.dispose();
                bullet.mesh.material.dispose();
                bullet.active = false;
            }
        }
    }
    
    checkCollisions(enemies) {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];
            if (!bullet.active) continue;
            
            for (let j = 0; j < enemies.length; j++) {
                const enemy = enemies[j];
                if (enemy.isDead) continue;
                
                const distance = bullet.mesh.position.distanceTo(enemy.mesh.position);
                if (distance < 0.5) {
                    // Ìó§ÎìúÏÉ∑ Ï≤¥ÌÅ¨ (Ï†ÅÏùò Î®∏Î¶¨ Î∂ÄÎ∂Ñ)
                    const headHeight = enemy.mesh.position.y + (enemy.mesh.scale.y || 1) * 0.5;
                    const isHeadshot = bullet.mesh.position.y > headHeight - 0.3;
                    
                    const damageDealt = enemy.takeDamage(bullet.damage, isHeadshot);
                    
                    // ÌîåÎ°úÌåÖ Îç∞ÎØ∏ÏßÄ ÌëúÏãú
                    if (window.game && window.game.floatingDamageSystem && window.game.camera) {
                        window.game.floatingDamageSystem.showDamage(
                            enemy.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)),
                            window.game.camera,
                            damageDealt,
                            isHeadshot
                        );
                    }
                    
                    // ÌûàÌä∏ ÎßàÏª§ ÌëúÏãú
                    if (window.game && window.game.hitMarkerSystem) {
                        window.game.hitMarkerSystem.show(isHeadshot);
                    }
                    
                    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨ (ÏïΩÍ∞Ñ)
                    if (window.game && window.game.cameraShakeSystem) {
                        window.game.cameraShakeSystem.shake(0.05, 0.1);
                    }
                    
                    // Ï∂©Îèå Ïä§ÌååÌÅ¨ Ìö®Í≥º
                    if (this.particleSystem) {
                        const direction = bullet.velocity.clone().normalize();
                        this.particleSystem.createSpark(bullet.mesh.position, direction);
                    }
                    
                    this.scene.remove(bullet.mesh);
                    bullet.mesh.geometry.dispose();
                    bullet.mesh.material.dispose();
                    bullet.active = false;
                    break;
                }
            }
        }
    }
}

// WeaponManager
class WeaponManager {
    constructor(camera, scene) {
        this.camera = camera;
        this.scene = scene;
        this.inputManager = new InputManager();
        
        this.weapons = [];
        this.currentWeaponIndex = 0;
        this.currentWeapon = null;
        this.enemyManager = null;
        this.particleSystem = null;
        
        this.onAmmoChanged = null;
        this.onWeaponChanged = null;
        
        this.init();
    }
    
    setParticleSystem(particleSystem) {
        this.particleSystem = particleSystem;
        // ÌòÑÏû¨ Î¨¥Í∏∞Ïóê ÌååÌã∞ÌÅ¥ ÏãúÏä§ÌÖú Ï†ÑÎã¨
        if (this.currentWeapon) {
            this.currentWeapon.particleSystem = particleSystem;
        }
    }
    
    init() {
        this.currentWeapon = new AcornBlaster(this.camera, this.scene);
        this.weapons.push(this.currentWeapon);
        
        if (this.onWeaponChanged) {
            this.onWeaponChanged(this.currentWeapon);
        }
    }
    
    setEnemyManager(enemyManager) {
        this.enemyManager = enemyManager;
    }
    
    update(deltaTime) {
        this.handleWeaponSwitching();
        this.handleShooting();
        this.handleReload();
        this.handleMelee();
        
        if (this.currentWeapon) {
            this.currentWeapon.update(deltaTime);
            if (this.currentWeapon.checkCollisions && this.enemyManager) {
                this.currentWeapon.checkCollisions(this.enemyManager.enemies);
            }
        }
    }
    
    handleWeaponSwitching() {
        if (this.inputManager.mouse.wheelDelta) {
            const delta = this.inputManager.mouse.wheelDelta > 0 ? 1 : -1;
            this.switchWeapon(delta);
            this.inputManager.mouse.wheelDelta = 0;
        }
        
        for (let i = 1; i <= 5; i++) {
            if (this.inputManager.isKeyPressed(`Digit${i}`)) {
                this.switchWeapon(i - 1 - this.currentWeaponIndex);
            }
        }
    }
    
    switchWeapon(offset) {
        if (this.weapons.length === 0) return;
        
        this.currentWeaponIndex = (this.currentWeaponIndex + offset + this.weapons.length) % this.weapons.length;
        this.currentWeapon = this.weapons[this.currentWeaponIndex];
        
        if (this.onWeaponChanged) {
            this.onWeaponChanged(this.currentWeapon);
        }
    }
    
    handleShooting() {
        if (this.currentWeapon && this.inputManager.isMouseButtonPressed(0)) {
            this.currentWeapon.shoot();
            
            if (this.onAmmoChanged) {
                this.onAmmoChanged(this.currentWeapon.currentAmmo, this.currentWeapon.maxAmmo);
            }
        }
    }
    
    handleReload() {
        if (this.inputManager.isKeyPressed('KeyR') && this.currentWeapon) {
            this.currentWeapon.reload();
        }
    }
    
    handleMelee() {
        if (this.inputManager.isMouseButtonPressed(2)) {
            this.performMeleeAttack();
        }
    }
    
    performMeleeAttack() {
    }
    
    addWeapon(weapon) {
        this.weapons.push(weapon);
    }
}

// EnemyBase
class EnemyBase {
    constructor(scene, type, position, player = null) {
        this.scene = scene;
        this.type = type;
        this.position = position.clone();
        
        // Í∏∞Î≥∏Í∞í (ÌÉÄÏûÖÎ≥ÑÎ°ú ÎçÆÏñ¥ÏîÄ)
        this.maxHealth = 20;
        this.currentHealth = this.maxHealth;
        this.speed = 3;
        
        // Ï†Å ÌÉÄÏûÖÏóê Îî∞Îùº Îã§Î•∏ ÏÑ§Ï†ï
        if (type === 'bunny') {
            // Í∑ºÏ†ë Í≥µÍ≤© Ï†Å (ÌÜ†ÎÅº)
            this.attackType = 'melee';
            this.attackRange = 2;
            this.attackDamage = 10;
            this.attackCooldown = 1.5;
            this.maxHealth = 20;
            this.speed = 5;
            this.resourceValue = 15;
        } else if (type === 'ranged') {
            // ÏõêÍ±∞Î¶¨ Í≥µÍ≤© Ï†Å
            this.attackType = 'ranged';
            this.attackRange = 15;
            this.attackDamage = 5;
            this.attackCooldown = 2;
            this.projectileSpeed = 10;
            this.maxHealth = 20;
            this.speed = 5; // ÏÜçÎèÑ Ï¶ùÍ∞Ä
            this.resourceValue = 15;
        } else if (type === 'tank') {
            // ÌÉ±ÌÅ¨Ìòï Ï†Å - ÎäêÎ¶¨ÏßÄÎßå Í∞ïÌï®
            this.attackType = 'melee';
            this.attackRange = 2.5;
            this.attackDamage = 15;
            this.attackCooldown = 1.2;
            this.maxHealth = 50;
            this.speed = 2.5; // ÏÜçÎèÑ Ï¶ùÍ∞Ä
            this.resourceValue = 30;
        } else if (type === 'fast') {
            // Îπ†Î•∏ Ï†Å - Îπ†Î•¥ÏßÄÎßå ÏïΩÌï®
            this.attackType = 'melee';
            this.attackRange = 1.5;
            this.attackDamage = 5;
            this.attackCooldown = 0.8;
            this.maxHealth = 10;
            this.speed = 8; // ÏÜçÎèÑ Ï¶ùÍ∞Ä
            this.resourceValue = 10;
        } else if (type === 'flyer') {
            // ÎπÑÌñâ Ï†Å - Îπ†Î•¥Í≥† Í≥µÏ§ë Ïù¥Îèô
            this.attackType = 'ranged';
            this.attackRange = 12;
            this.attackDamage = 8;
            this.attackCooldown = 1.5;
            this.projectileSpeed = 12;
            this.maxHealth = 15;
            this.speed = 7;
            this.isFlying = true;
            this.resourceValue = 20;
        } else if (type === 'charger') {
            // ÎèåÏßÑÌòï Ï†Å - Îß§Ïö∞ Îπ†Î•¥Í≥† Í∞ïÌï®
            this.attackType = 'melee';
            this.attackRange = 2;
            this.attackDamage = 20;
            this.attackCooldown = 2;
            this.maxHealth = 30;
            this.speed = 10;
            this.chargeCooldown = 3;
            this.lastChargeTime = 0;
            this.resourceValue = 25;
        } else {
            // Í∑ºÏ†ë Í≥µÍ≤© Ï†Å (Í∏∞Î≥∏)
            this.attackType = 'melee';
            this.attackRange = 2;
            this.attackDamage = 10;
            this.attackCooldown = 1.5;
            this.maxHealth = 20;
            this.speed = 5; // ÏÜçÎèÑ Ï¶ùÍ∞Ä
            this.resourceValue = 15;
        }
        
        this.currentHealth = this.maxHealth;
        
        this.attackTimer = 0;
        this.staggerThreshold = 3;
        this.hitCount = 0;
        this.isStaggered = false;
        
        this.isDead = false;
        this.target = player;
        this.towerTarget = null; // ÌÉÄÏõå ÌÉÄÍ≤ü (ÎîîÌéúÏä§ Í≤åÏûÑÏö©)
        this.playerController = null; // ÌîåÎ†àÏù¥Ïñ¥ Ïª®Ìä∏Î°§Îü¨ Ï∞∏Ï°∞
        this.enemyManager = null; // EnemyManager Ï∞∏Ï°∞
        this.resourceValue = 10; // Ï≤òÏπò Ïãú Î¶¨ÏÜåÏä§
        this.isFlying = false; // ÎπÑÌñâ Ïó¨Î∂Ä
        
        this.onDeath = null;
        
        this.createMesh();
    }
    
    setPlayerController(playerController) {
        this.playerController = playerController;
    }
    
    setEnemyManager(enemyManager) {
        this.enemyManager = enemyManager;
    }
    
    createMesh() {
        // Ï†Å ÌÉÄÏûÖÏóê Îî∞Îùº Îã§Î•∏ Î™®Ïäµ (ÌÉÄÏûÖ Ïö∞ÏÑ† Ï≤¥ÌÅ¨)
        if (this.type === 'tank') {
            // ÌÉ±ÌÅ¨Ìòï Ï†Å - ÌÅ¨Í≥† Í∞ïÌï®
            const bodyGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a, // ÌöåÏÉâ
                roughness: 0.7,
                metalness: 0.3
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.6;
            
            // Í∞ëÏò∑ ÌîåÎ†àÏù¥Ìä∏
            const plateGeometry = new THREE.BoxGeometry(1.4, 0.2, 1.4);
            const plateMaterial = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
            const topPlate = new THREE.Mesh(plateGeometry, plateMaterial);
            topPlate.position.set(0, 0.7, 0);
            this.mesh.add(topPlate);
            
            // Îàà (Îπ®Í∞ÑÏÉâÏúºÎ°ú ÏúÑÌòëÏ†Å)
            const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 0.3, 0.6);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 0.3, 0.6);
            this.mesh.add(rightEye);
            
        } else if (this.type === 'fast') {
            // Îπ†Î•∏ Ï†Å - ÏûëÍ≥† Îπ†Î¶Ñ
            const bodyGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, // Ï¥àÎ°ùÏÉâ
                roughness: 0.8,
                emissive: 0x00ff00,
                emissiveIntensity: 0.3
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.3, 0.7);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.4;
            
            // Í∏¥ Í∑Ä
            const earGeometry = new THREE.ConeGeometry(0.1, 0.5, 6);
            const earMaterial = new THREE.MeshStandardMaterial({ color: 0x00cc00 });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.3, 0.5, 0);
            leftEar.rotation.z = -0.3;
            this.mesh.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.3, 0.5, 0);
            rightEar.rotation.z = 0.3;
            this.mesh.add(rightEar);
            
            // Îàà
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 0.1, 0.3);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 0.1, 0.3);
            this.mesh.add(rightEye);
            
        } else if (this.type === 'flyer') {
            // ÎπÑÌñâ Ï†Å - ÏÉà Î™®Ïäµ
            const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169E1, // ÌååÎûÄÏÉâ
                roughness: 0.8,
                emissive: 0x4169E1,
                emissiveIntensity: 0.2
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.1, 0.9);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 2; // Í≥µÏ§ë
            
            // ÎÇ†Í∞ú (Îçî ÌÅ¨Í≤å)
            const wingGeometry = new THREE.BoxGeometry(0.5, 0.15, 1.2);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.6, 0.2, 0);
            leftWing.rotation.z = 0.5;
            this.mesh.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.6, 0.2, 0);
            rightWing.rotation.z = -0.5;
            this.mesh.add(rightWing);
            
            // Î∂ÄÎ¶¨
            const beakGeometry = new THREE.ConeGeometry(0.15, 0.4, 6);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xffa502 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(0, 0, 0.6);
            beak.rotation.x = Math.PI / 2;
            this.mesh.add(beak);
            
            // Îàà
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 0.2, 0.5);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 0.2, 0.5);
            this.mesh.add(rightEye);
            
        } else if (this.type === 'charger') {
            // ÎèåÏßÑÌòï Ï†Å - Îøî ÏûàÎäî ÎèôÎ¨º
            const bodyGeometry = new THREE.SphereGeometry(0.7, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000, // ÏßÑÌïú Îπ®Í∞ÑÏÉâ
                roughness: 0.9,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.2, 1.1);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.7;
            
            // Îøî
            const hornGeometry = new THREE.ConeGeometry(0.1, 0.6, 6);
            const hornMaterial = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
            
            const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            leftHorn.position.set(-0.3, 0.6, 0.5);
            leftHorn.rotation.z = -0.3;
            this.mesh.add(leftHorn);
            
            const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            rightHorn.position.set(0.3, 0.6, 0.5);
            rightHorn.rotation.z = 0.3;
            this.mesh.add(rightHorn);
            
            // Îàà (Îπ®Í∞ÑÏÉâ)
            const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.25, 0.2, 0.7);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.25, 0.2, 0.7);
            this.mesh.add(rightEye);
            
        } else if (this.type === 'ranged' || this.attackType === 'ranged') {
            // ÏõêÍ±∞Î¶¨ Í≥µÍ≤© Ï†Å - ÏÉà Î™®Ïäµ
            const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff6b6b, // Îπ®Í∞ÑÏÉâ
                roughness: 0.8
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.1, 0.9);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.5;
            
            // ÎÇ†Í∞ú
            const wingGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.8);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0xff4757 });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.4, 0.2, 0);
            leftWing.rotation.z = 0.3;
            this.mesh.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.4, 0.2, 0);
            rightWing.rotation.z = -0.3;
            this.mesh.add(rightWing);
            
            // Î∂ÄÎ¶¨
            const beakGeometry = new THREE.ConeGeometry(0.1, 0.3, 6);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xffa502 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(0, 0, 0.5);
            beak.rotation.x = Math.PI / 2;
            this.mesh.add(beak);
            
            // Îàà
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 0.15, 0.4);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 0.15, 0.4);
            this.mesh.add(rightEye);
            
        } else if (this.type === 'bunny' || this.attackType === 'melee') {
            // Í∑ºÏ†ë Í≥µÍ≤© Ï†Å - Í≥∞ Î™®Ïäµ
            const bodyGeometry = new THREE.SphereGeometry(0.8, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b4513, // Í∞àÏÉâ
                roughness: 0.9
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.1, 0.9);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.8;
            
            // Í∑Ä
            const earGeometry = new THREE.SphereGeometry(0.25, 8, 8);
            const earMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.5, 0.6, 0.3);
            this.mesh.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.5, 0.6, 0.3);
            this.mesh.add(rightEar);
            
            // Îàà
            const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 0.2, 0.7);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 0.2, 0.7);
            this.mesh.add(rightEye);
            
            // Î∞úÌÜ± (Í∑ºÏ†ë Í≥µÍ≤© Í∞ïÏ°∞)
            const clawGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.3);
            const clawMaterial = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
            
            const leftClaw = new THREE.Mesh(clawGeometry, clawMaterial);
            leftClaw.position.set(-0.4, -0.5, 0.5);
            this.mesh.add(leftClaw);
            
            const rightClaw = new THREE.Mesh(clawGeometry, clawMaterial);
            rightClaw.position.set(0.4, -0.5, 0.5);
            this.mesh.add(rightClaw);
            
        } else if (this.type === 'flyer') {
            // ÎπÑÌñâ Ï†Å - ÏÉà Î™®Ïäµ
            const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169E1, // ÌååÎûÄÏÉâ
                roughness: 0.8,
                emissive: 0x4169E1,
                emissiveIntensity: 0.2
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.1, 0.9);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 2; // Í≥µÏ§ë
            
            // ÎÇ†Í∞ú (Îçî ÌÅ¨Í≤å)
            const wingGeometry = new THREE.BoxGeometry(0.5, 0.15, 1.2);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.6, 0.2, 0);
            leftWing.rotation.z = 0.5;
            this.mesh.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.6, 0.2, 0);
            rightWing.rotation.z = -0.5;
            this.mesh.add(rightWing);
            
            // Î∂ÄÎ¶¨
            const beakGeometry = new THREE.ConeGeometry(0.15, 0.4, 6);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xffa502 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(0, 0, 0.6);
            beak.rotation.x = Math.PI / 2;
            this.mesh.add(beak);
            
            // Îàà
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 0.2, 0.5);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 0.2, 0.5);
            this.mesh.add(rightEye);
            
        } else if (this.type === 'charger') {
            // ÎèåÏßÑÌòï Ï†Å - Îøî ÏûàÎäî ÎèôÎ¨º
            const bodyGeometry = new THREE.SphereGeometry(0.7, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000, // ÏßÑÌïú Îπ®Í∞ÑÏÉâ
                roughness: 0.9,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.2, 1.1);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.7;
            
            // Îøî
            const hornGeometry = new THREE.ConeGeometry(0.1, 0.6, 6);
            const hornMaterial = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
            
            const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            leftHorn.position.set(-0.3, 0.6, 0.5);
            leftHorn.rotation.z = -0.3;
            this.mesh.add(leftHorn);
            
            const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            rightHorn.position.set(0.3, 0.6, 0.5);
            rightHorn.rotation.z = 0.3;
            this.mesh.add(rightHorn);
            
            // Îàà (Îπ®Í∞ÑÏÉâ)
            const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.25, 0.2, 0.7);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.25, 0.2, 0.7);
            this.mesh.add(rightEye);
            
        } else if (this.type === 'bear') {
            // Í≥∞ Î™®Ïäµ
            const bodyGeometry = new THREE.SphereGeometry(0.8, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b4513, // Í∞àÏÉâ
                roughness: 0.9
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.1, 0.9);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.8;
            
            // Í∑Ä
            const earGeometry = new THREE.SphereGeometry(0.25, 8, 8);
            const earMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.5, 0.6, 0.3);
            this.mesh.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.5, 0.6, 0.3);
            this.mesh.add(rightEar);
            
            // Îàà
            const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 0.2, 0.7);
            this.mesh.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 0.2, 0.7);
            this.mesh.add(rightEye);
            
        } else {
            // Í∏∞Î≥∏ (ÌÜ†ÎÅºÏôÄ Ïú†ÏÇ¨)
            const bodyGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5deb3,
                roughness: 0.8
            });
            this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            this.mesh.scale.set(1, 1.2, 0.8);
            this.mesh.position.copy(this.position);
            this.mesh.position.y += 0.6;
        }
        
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.scene.add(this.mesh);
    }
    
    update(deltaTime) {
        if (this.isDead) return;
        
        // Í≥µÍ≤© ÌÉÄÏù¥Î®∏ Í∞êÏÜå
        if (this.attackTimer > 0) {
            this.attackTimer -= deltaTime;
        }
        
        if (this.target || this.towerTarget) {
            this.moveTowardsTarget(deltaTime);
            if (!this.towerTarget) {
                this.checkAttack();
            }
        }
    }
    
    moveTowardsTarget(deltaTime) {
        // ÌÉÄÏõå ÌÉÄÍ≤ü Ïö∞ÏÑ† (ÎîîÌéúÏä§ Í≤åÏûÑ)
        let targetPos = null;
        if (this.towerTarget) {
            targetPos = this.towerTarget.getPosition();
        } else if (this.target) {
            targetPos = this.target.position || this.target;
        }
        
        if (!targetPos) return;
        
        const distance = this.position.distanceTo(targetPos);
        
        // ÌÉÄÏõåÏóê ÎèÑÎã¨ÌïòÎ©¥ ÌÉÄÏõå Í≥µÍ≤©
        if (this.towerTarget && distance < this.attackRange) {
            // Í≥µÍ≤© ÌÉÄÏù¥Î®∏Îäî update()ÏóêÏÑú Ïù¥ÎØ∏ Í∞êÏÜåÎê®
            if (this.attackTimer <= 0) {
                this.towerTarget.takeDamage(this.attackDamage);
                this.attackTimer = this.attackCooldown;
            }
            if (this.mesh) {
                this.mesh.position.copy(this.position);
                if (this.isFlying) {
                    this.mesh.position.y = this.position.y + 2;
                }
                this.mesh.lookAt(targetPos);
            }
            return;
        }
        
        // ÌÉÄÏõåÎ•º Ìñ•Ìï¥ Ïù¥ÎèôÌïòÍ±∞ÎÇò Í∑ºÏ†ë Ï†ÅÏù¥Î©¥ Îã§Í∞ÄÍ∞ÄÍ∏∞
        if (this.towerTarget || this.attackType === 'melee' || distance > this.attackRange) {
            const direction = new THREE.Vector3()
                .subVectors(targetPos, this.position)
                .normalize();
            
            // charger ÌÉÄÏûÖÏùÄ ÎèåÏßÑ
            let moveSpeed = this.speed;
            if (this.type === 'charger') {
                const now = Date.now();
                if (now - (this.lastChargeTime || 0) > (this.chargeCooldown || 3) * 1000) {
                    moveSpeed *= 2; // ÎèåÏßÑ Î™®Îìú
                    this.lastChargeTime = now;
                }
            }
            
            const speed = this.isStaggered ? moveSpeed * 0.5 : moveSpeed;
            this.position.add(direction.multiplyScalar(speed * deltaTime));
        } else if (this.attackType === 'ranged' && distance < this.attackRange * 0.8 && !this.towerTarget) {
            // ÏõêÍ±∞Î¶¨ Ï†ÅÏù¥ ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÎÑàÎ¨¥ Í∞ÄÍπåÏö∞Î©¥ Îí§Î°ú Ïù¥Îèô (ÌÉÄÏõå ÏïÑÎãê ÎïåÎßå)
            const direction = new THREE.Vector3()
                .subVectors(this.position, targetPos)
                .normalize();
            this.position.add(direction.multiplyScalar(this.speed * deltaTime * 0.5));
        }
        
        if (this.mesh) {
            this.mesh.position.copy(this.position);
            if (this.isFlying) {
                this.mesh.position.y = this.position.y + 2; // Í≥µÏ§ë Ïù¥Îèô
            }
            this.mesh.lookAt(targetPos);
        }
    }
    
    attackTower(deltaTime) {
        if (!this.towerTarget || this.towerTarget.isDestroyed) return;
        
        // Í≥µÍ≤© ÌÉÄÏù¥Î®∏ Ï≤¥ÌÅ¨ (updateÏóêÏÑú Ïù¥ÎØ∏ Í∞êÏÜåÏãúÌÇ¥)
        if (this.attackTimer <= 0) {
            this.towerTarget.takeDamage(this.attackDamage);
            this.attackTimer = this.attackCooldown;
        }
    }
    
    setTowerTarget(tower) {
        this.towerTarget = tower;
    }
    
    checkAttack() {
        if (!this.target || !this.playerController) return;
        
        // Í≥µÍ≤© ÌÉÄÏù¥Î®∏Îäî update()ÏóêÏÑú Ïù¥ÎØ∏ Í∞êÏÜåÎê®
        const targetPos = this.target.position || this.target;
        const distance = this.position.distanceTo(targetPos);
        
        if (distance <= this.attackRange && this.attackTimer <= 0) {
            if (this.attackType === 'melee') {
                // Í∑ºÏ†ë Í≥µÍ≤©
                this.playerController.takeDamage(this.attackDamage);
                this.attackTimer = this.attackCooldown;
            } else if (this.attackType === 'ranged') {
                // ÏõêÍ±∞Î¶¨ Í≥µÍ≤© - Ìà¨ÏÇ¨Ï≤¥ Î∞úÏÇ¨
                if (this.enemyManager) {
                    this.shootProjectile(targetPos, this.enemyManager);
                    this.attackTimer = this.attackCooldown;
                }
            }
        }
    }
    
    shootProjectile(targetPos, enemyManager) {
        const direction = new THREE.Vector3()
            .subVectors(targetPos, this.position)
            .normalize();
        
        // Ìà¨ÏÇ¨Ï≤¥ ÏÉùÏÑ±
        const projectileGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const projectileMesh = new THREE.Mesh(projectileGeometry, projectileMaterial);
        projectileMesh.position.copy(this.position);
        projectileMesh.position.y += 0.5;
        this.scene.add(projectileMesh);
        
        const velocity = direction.multiplyScalar(this.projectileSpeed);
        const startPos = projectileMesh.position.clone();
        
        // Ìà¨ÏÇ¨Ï≤¥ Í∞ùÏ≤¥ ÏÉùÏÑ±
        const projectile = {
            mesh: projectileMesh,
            position: projectileMesh.position.clone(),
            velocity: velocity,
            startPos: startPos,
            damage: this.attackDamage,
            maxRange: this.attackRange * 2
        };
        
        // EnemyManagerÏóê Ï∂îÍ∞Ä
        if (enemyManager) {
            enemyManager.addProjectile(projectile);
        }
    }
    
    takeDamage(amount, isHeadshot = false) {
        if (this.isDead) return 0;
        
        this.lastHitWasHeadshot = isHeadshot;
        
        const originalAmount = amount;
        if (isHeadshot) {
            amount *= 2;
        }
        
        this.currentHealth -= amount;
        this.hitCount++;
        
        if (this.hitCount >= this.staggerThreshold && !this.isStaggered) {
            this.stagger();
        }
        
        if (this.currentHealth <= 0) {
            this.die();
        }
        
        return amount; // Ïã§Ï†ú Îç∞ÎØ∏ÏßÄ Î∞òÌôò
    }
    
    stagger() {
        this.isStaggered = true;
        setTimeout(() => {
            this.isStaggered = false;
            this.hitCount = 0;
        }, 2000);
    }
    
    die() {
        if (this.isDead) return;
        
        this.isDead = true;
        
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        
        if (this.onDeath) {
            this.onDeath();
        }
    }
    
    dispose() {
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }
    }
}

// EnemyManager
class EnemyManager {
    constructor(scene) {
        this.scene = scene;
        this.enemies = [];
        this.projectiles = []; // Ìà¨ÏÇ¨Ï≤¥ Í¥ÄÎ¶¨
        this.spawnPoints = [];
        this.currentWave = 0;
        this.enemiesPerWave = 5;
        this.waveCooldown = 10;
        this.player = null;
        
        this.onEnemyKilled = null;
        this.onWaveComplete = null;
        this.onWaveStart = null;
        
        this.waveCompleteChecked = false; // Ïõ®Ïù¥Î∏å ÏôÑÎ£å Ï≤¥ÌÅ¨ ÌîåÎûòÍ∑∏
    }
    
    update(deltaTime) {
        // Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
        this.enemies.forEach(enemy => {
            if (enemy && enemy.update) {
                enemy.update(deltaTime);
            }
        });
        
        // Ï£ΩÏùÄ Ï†Å Ï†úÍ±∞
        this.enemies = this.enemies.filter(enemy => !enemy.isDead);
        
        // Ïõ®Ïù¥Î∏å ÏôÑÎ£å Ï≤¥ÌÅ¨ (Ï†ÅÏù¥ Î™®Îëê Ï≤òÏπòÎêòÍ≥† Ïõ®Ïù¥Î∏åÍ∞Ä ÏßÑÌñâ Ï§ëÏùº Îïå, Ìïú Î≤àÎßå)
        if (this.currentWave > 0 && this.enemies.length === 0 && this.onWaveComplete && !this.waveCompleteChecked) {
            this.waveCompleteChecked = true;
            // ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ Ïõ®Ïù¥Î∏å ÏôÑÎ£å ÏΩúÎ∞±
            setTimeout(() => {
                if (this.onWaveComplete && this.enemies.length === 0) {
                    this.onWaveComplete();
                }
                // ÏûêÎèôÏúºÎ°ú Îã§Ïùå Ïõ®Ïù¥Î∏å ÏãúÏûë (3Ï¥à ÌõÑ)
                setTimeout(() => {
                    this.waveCompleteChecked = false;
                    if (this.enemies.length === 0) {
                        this.startWave();
                    }
                }, 3000);
            }, 1000);
        }
        
        // Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏ (Ïó≠ÏàúÏúºÎ°ú ÏàúÌöåÌïòÏó¨ ÏïàÏ†ÑÌïòÍ≤å Ï†úÍ±∞)
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const projectile = this.projectiles[i];
            if (!projectile || !projectile.mesh) {
                this.projectiles.splice(i, 1);
                continue;
            }
            
            projectile.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
            projectile.mesh.position.copy(projectile.position);
            
            // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå Ï≤¥ÌÅ¨
            if (this.player && this.player.camera) {
                const distance = projectile.position.distanceTo(this.player.camera.position);
                if (distance < 0.5) {
                    this.player.takeDamage(projectile.damage);
                    this.removeProjectile(i);
                    continue;
                }
            }
            
            // ÏÇ¨Í±∞Î¶¨ Ï≤¥ÌÅ¨
            if (projectile.position.distanceTo(projectile.startPos) > projectile.maxRange) {
                this.removeProjectile(i);
            }
        }
    }
    
    addProjectile(projectile) {
        this.projectiles.push(projectile);
    }
    
    removeProjectile(index) {
        if (this.projectiles[index]) {
            const projectile = this.projectiles[index];
            if (projectile.mesh) {
                this.scene.remove(projectile.mesh);
                projectile.mesh.geometry.dispose();
                projectile.mesh.material.dispose();
            }
            this.projectiles.splice(index, 1);
        }
    }
    
    spawnEnemy(type, position, player = null, playerController = null) {
        let enemy;
        if (type === 'boss') {
            enemy = new BossEnemy(this.scene, position, player);
        } else {
            enemy = new EnemyBase(this.scene, type, position, player);
        }
        enemy.setPlayerController(playerController);
        enemy.setEnemyManager(this); // EnemyManager Ï∞∏Ï°∞ ÏÑ§Ï†ï
        enemy.onDeath = () => {
            const isHeadshot = enemy.lastHitWasHeadshot || false;
            this.removeEnemy(enemy);
            if (this.onEnemyKilled) {
                this.onEnemyKilled(enemy, isHeadshot);
            }
        };
        this.enemies.push(enemy);
        return enemy;
    }
    
    setPlayer(player) {
        this.player = player;
        this.enemies.forEach(enemy => {
            enemy.target = player ? player.camera : null;
            enemy.setPlayerController(player);
        });
    }
    
    removeEnemy(enemy) {
        const index = this.enemies.indexOf(enemy);
        if (index > -1) {
            this.enemies.splice(index, 1);
        }
    }
    
    startWave() {
        this.currentWave++;
        const waveSize = this.enemiesPerWave + Math.floor(this.currentWave / 2); // Ïõ®Ïù¥Î∏åÎßàÎã§ Ï†Å Ï¶ùÍ∞Ä
        
        for (let i = 0; i < waveSize; i++) {
            const spawnPoint = this.getRandomSpawnPoint();
            // Îã§ÏñëÌïú Ï†Å ÌÉÄÏûÖ ÎûúÎç§ ÏÉùÏÑ± (ÎîîÌéúÏä§ Í≤åÏûÑÏö©)
            const rand = Math.random();
            let enemyType;
            if (rand < 0.3) {
                enemyType = 'bunny'; // Í∑ºÏ†ë Í≥µÍ≤© (30%)
            } else if (rand < 0.5) {
                enemyType = 'ranged'; // ÏõêÍ±∞Î¶¨ Í≥µÍ≤© (20%)
            } else if (rand < 0.65) {
                enemyType = 'fast'; // Îπ†Î•∏ Ï†Å (15%)
            } else if (rand < 0.8) {
                enemyType = 'tank'; // ÌÉ±ÌÅ¨Ìòï Ï†Å (15%)
            } else if (rand < 0.9) {
                enemyType = 'flyer'; // ÎπÑÌñâ Ï†Å (10%)
            } else {
                enemyType = 'charger'; // ÎèåÏßÑÌòï Ï†Å (10%)
            }
            this.spawnEnemy(
                enemyType, 
                spawnPoint, 
                this.player ? this.player.camera : null,
                this.player
            );
        }
        
        // Game ÌÅ¥ÎûòÏä§Ïóê Ïõ®Ïù¥Î∏å Ï†ïÎ≥¥ Ï†ÑÎã¨
        if (this.onWaveStart) {
            this.onWaveStart(this.currentWave);
        }
        
        // Î≥¥Ïä§ Ïä§Ìè∞ Ï≤¥ÌÅ¨Îäî Game ÌÅ¥ÎûòÏä§ÏóêÏÑú Ï≤òÎ¶¨
        // Ïõ®Ïù¥Î∏å ÏôÑÎ£å Ï≤¥ÌÅ¨Îäî update()ÏóêÏÑú Ï≤òÎ¶¨
    }
    
    getRandomSpawnPoint() {
        if (this.spawnPoints.length === 0) {
            return new THREE.Vector3(
                (Math.random() - 0.5) * 180,
                1,
                (Math.random() - 0.5) * 180
            );
        }
        return this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)];
    }
    
    clearAllEnemies() {
        this.enemies.forEach(enemy => {
            if (enemy.dispose) {
                enemy.dispose();
            }
        });
        this.enemies = [];
    }
}

// StageManager
class StageManager {
    constructor(scene) {
        this.scene = scene;
        this.currentStage = null;
        this.stages = {
            mossyMeadow: {
                name: 'Mossy Meadow',
                music: 'mossyMeadow',
                enemies: ['bunny'],
                spawnPoints: []
            },
            shroomHollow: {
                name: 'Shroom Hollow',
                music: 'shroomHollow',
                enemies: ['bunny', 'bear'],
                spawnPoints: []
            },
            wreckedFactory: {
                name: 'Wrecked Factory',
                music: 'wreckedFactory',
                enemies: ['deer'],
                spawnPoints: []
            },
            trashTown: {
                name: 'Trash Town',
                music: 'trashTown',
                enemies: ['boss'],
                spawnPoints: []
            }
        };
        
        this.onStageChanged = null;
    }
    
    async loadStage(stageKey) {
        const stage = this.stages[stageKey];
        if (!stage) return;
        
        this.currentStage = stage;
        
        this.createStageGeometry(stageKey);
        this.setupSpawnPoints(stageKey);
        
        if (this.onStageChanged) {
            this.onStageChanged(stage.name);
        }
    }
    
    createStageGeometry(stageKey) {
        switch(stageKey) {
            case 'mossyMeadow':
                this.createMossyMeadow();
                break;
            case 'shroomHollow':
                this.createShroomHollow();
                break;
            case 'wreckedFactory':
                this.createWreckedFactory();
                break;
            case 'trashTown':
                this.createTrashTown();
                break;
        }
    }
    
    createMossyMeadow() {
        const mapSize = 200;
        
        // ÏßÄÌòï ÌÖçÏä§Ï≤òÎ•º ÏúÑÌïú Ïó¨Îü¨ Î†àÏù¥Ïñ¥
        const floorGeometry = new THREE.PlaneGeometry(mapSize, mapSize, 20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5016, // ÏßÑÌïú Ï¥àÎ°ùÏÉâ - ÌôïÏã§ÌïòÍ≤å
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0; // Î™ÖÏãúÏ†ÅÏúºÎ°ú Y=0Ïóê Î∞∞Ïπò
        floor.receiveShadow = true;
        floor.name = 'ground';
        this.scene.add(floor);
        
        // Î∞îÎã•Ïù¥ ÌôïÏã§Ìûà Î≥¥Ïù¥ÎèÑÎ°ù Í∞ïÏ†ú ÏóÖÎç∞Ïù¥Ìä∏
        floor.material.needsUpdate = true;
        floor.material.color.setHex(0x2d5016);
        
        // ÏßÄÌòï ÎÜíÏù¥ Î≥ÄÌôî Ï†úÍ±∞ - ÌèâÌèâÌïú Î∞îÎã•ÏúºÎ°ú (ÎÇòÏ§ëÏóê Í∞úÏÑ†)
        // const vertices = floor.geometry.attributes.position;
        // for (let i = 0; i < vertices.count; i++) {
        //     const x = vertices.getX(i);
        //     const z = vertices.getZ(i);
        //     const y = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 0.5;
        //     vertices.setY(i, y);
        // }
        // vertices.needsUpdate = true;
        // floor.geometry.computeVertexNormals();
        
        this.createWalls(mapSize/2, 25, 0x6b4423);
        
        // Ï§ëÏïô Íµ¨Ï°∞Î¨ºÏùÄ Game ÌÅ¥ÎûòÏä§ÏóêÏÑú ÌÉÄÏõåÎ°ú ÏÉùÏÑ±Îê® (Ï†úÍ±∞)
        // this.createCentralStructure(0, 0, 15);
        
        // ÎÇòÎ¨¥Îì§ - Îçî ÏûêÏó∞Ïä§ÎüΩÍ≤å Î∞∞Ïπò
        for (let i = 0; i < 80; i++) {
            this.createTree(
                (Math.random() - 0.5) * (mapSize - 20),
                (Math.random() - 0.5) * (mapSize - 20)
            );
        }
        
        // Ïû•Ïï†Î¨º Íµ¨Ï°∞Î¨ºÎì§
        for (let i = 0; i < 15; i++) {
            this.createObstacleStructure(
                (Math.random() - 0.5) * (mapSize - 40),
                (Math.random() - 0.5) * (mapSize - 40)
            );
        }
        
        // ÌíÄÎì§
        for (let i = 0; i < 200; i++) {
            this.createGrass(
                (Math.random() - 0.5) * (mapSize - 20),
                (Math.random() - 0.5) * (mapSize - 20)
            );
        }
        
        // ÍΩÉÎì§
        for (let i = 0; i < 100; i++) {
            this.createFlower(
                (Math.random() - 0.5) * (mapSize - 20),
                (Math.random() - 0.5) * (mapSize - 20)
            );
        }
        
        // ÎèåÎì§
        for (let i = 0; i < 30; i++) {
            this.createRock(
                (Math.random() - 0.5) * (mapSize - 20),
                (Math.random() - 0.5) * (mapSize - 20)
            );
        }
    }
    
    createCentralStructure(x, z, size) {
        // Ï§ëÏïô ÌÉÄÏõå
        const towerGeometry = new THREE.CylinderGeometry(size * 0.3, size * 0.4, size * 0.8, 8);
        const towerMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513,
            roughness: 0.9
        });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.set(x, size * 0.4, z);
        tower.castShadow = true;
        tower.receiveShadow = true;
        this.scene.add(tower);
        
        // Ï£ºÎ≥Ä Î≤Ω
        const wallHeight = size * 0.3;
        const wallThickness = 1;
        const wallLength = size * 0.6;
        
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x6b4423 });
        const walls = [
            { pos: [x - wallLength/2, wallHeight/2, z], size: [wallThickness, wallHeight, wallLength] },
            { pos: [x + wallLength/2, wallHeight/2, z], size: [wallThickness, wallHeight, wallLength] },
            { pos: [x, wallHeight/2, z - wallLength/2], size: [wallLength, wallHeight, wallThickness] },
            { pos: [x, wallHeight/2, z + wallLength/2], size: [wallLength, wallHeight, wallThickness] }
        ];
        
        walls.forEach(wall => {
            const geometry = new THREE.BoxGeometry(...wall.size);
            const mesh = new THREE.Mesh(geometry, wallMaterial);
            mesh.position.set(...wall.pos);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            this.scene.add(mesh);
        });
    }
    
    createObstacleStructure(x, z) {
        // Îã§ÏñëÌïú ÎÜíÏù¥Ïùò Ïû•Ïï†Î¨º
        const height = 2 + Math.random() * 3;
        const width = 1 + Math.random() * 2;
        const depth = 1 + Math.random() * 2;
        
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({ 
            color: new THREE.Color().setHSL(0.1, 0.3, 0.3 + Math.random() * 0.2),
            roughness: 0.8
        });
        const obstacle = new THREE.Mesh(geometry, material);
        obstacle.position.set(x, height / 2, z);
        obstacle.rotation.y = Math.random() * Math.PI * 2;
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        this.scene.add(obstacle);
        
        // ÏúÑÏóê ÏûëÏùÄ Ïû•Ïãù
        if (Math.random() > 0.5) {
            const decorationGeometry = new THREE.SphereGeometry(0.3, 6, 6);
            const decorationMaterial = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
            const decoration = new THREE.Mesh(decorationGeometry, decorationMaterial);
            decoration.position.set(x, height + 0.3, z);
            this.scene.add(decoration);
        }
    }
    
    createGrass(x, z) {
        const grassGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
        const grassMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4caf50,
            roughness: 0.8
        });
        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
        grass.position.set(x, 0.15, z);
        grass.rotation.z = (Math.random() - 0.5) * 0.3;
        this.scene.add(grass);
    }
    
    createFlower(x, z) {
        // ÍΩÉÏûé
        const petalGeometry = new THREE.SphereGeometry(0.05, 6, 6);
        const petalMaterial = new THREE.MeshStandardMaterial({ 
            color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6),
            roughness: 0.5
        });
        
        for (let i = 0; i < 5; i++) {
            const petal = new THREE.Mesh(petalGeometry, petalMaterial);
            const angle = (i / 5) * Math.PI * 2;
            petal.position.set(
                x + Math.cos(angle) * 0.08,
                0.1,
                z + Math.sin(angle) * 0.08
            );
            petal.scale.set(1, 0.3, 1);
            this.scene.add(petal);
        }
        
        // ÍΩÉ Ï§ëÏã¨
        const centerGeometry = new THREE.SphereGeometry(0.03, 8, 8);
        const centerMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });
        const center = new THREE.Mesh(centerGeometry, centerMaterial);
        center.position.set(x, 0.1, z);
        this.scene.add(center);
    }
    
    createRock(x, z) {
        const rockGeometry = new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.2, 0);
        const rockMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x757575,
            roughness: 1.0
        });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(x, 0.3, z);
        rock.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );
        rock.castShadow = true;
        this.scene.add(rock);
    }
    
    createShroomHollow() {
        const mapSize = 200;
        const floorGeometry = new THREE.PlaneGeometry(mapSize, mapSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x9370DB
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        this.scene.add(floor);
        
        for (let i = 0; i < 60; i++) {
            this.createGlowingMushroom(
                (Math.random() - 0.5) * (mapSize - 20),
                (Math.random() - 0.5) * (mapSize - 20)
            );
        }
    }
    
    createWreckedFactory() {
        const mapSize = 200;
        const floorGeometry = new THREE.PlaneGeometry(mapSize, mapSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x708090
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        this.scene.add(floor);
        
        this.createMachineStructures();
    }
    
    createTrashTown() {
        const mapSize = 200;
        const floorGeometry = new THREE.PlaneGeometry(mapSize, mapSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2F4F4F
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        this.scene.add(floor);
        
        this.createNeonStructures();
    }
    
    createWalls(width, height, color) {
        const wallMaterial = new THREE.MeshStandardMaterial({ color });
        const wallThickness = 1;
        
        const walls = [
            { pos: [0, height/2, -width/2], size: [width, height, wallThickness] },
            { pos: [0, height/2, width/2], size: [width, height, wallThickness] },
            { pos: [-width/2, height/2, 0], size: [wallThickness, height, width] },
            { pos: [width/2, height/2, 0], size: [wallThickness, height, width] }
        ];
        
        walls.forEach(wall => {
            const geometry = new THREE.BoxGeometry(...wall.size);
            const mesh = new THREE.Mesh(geometry, wallMaterial);
            mesh.position.set(...wall.pos);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            this.scene.add(mesh);
        });
    }
    
    createTree(x, z) {
        // ÎÇòÎ¨¥ Ï§ÑÍ∏∞ - ÎÜíÏù¥ÏôÄ ÎëêÍªò Îã§ÏñëÌôî
        const trunkHeight = 2 + Math.random() * 2;
        const trunkRadius = 0.2 + Math.random() * 0.2;
        const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x6b4423,
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.set(x, trunkHeight / 2, z);
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        this.scene.add(trunk);
        
        // ÎÇòÎ≠áÏûé - Ïó¨Îü¨ Î†àÏù¥Ïñ¥Î°ú ÏûêÏó∞Ïä§ÎüΩÍ≤å
        const leafLayers = 2 + Math.floor(Math.random() * 2);
        for (let i = 0; i < leafLayers; i++) {
            const leafSize = 1.5 + Math.random() * 1;
            const leafHeight = 1 + Math.random() * 0.5;
            const leavesGeometry = new THREE.ConeGeometry(leafSize, leafHeight, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.6, 0.4),
                roughness: 0.8
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(
                x + (Math.random() - 0.5) * 0.3,
                trunkHeight + i * 0.8,
                z + (Math.random() - 0.5) * 0.3
            );
            leaves.rotation.z = (Math.random() - 0.5) * 0.2;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            this.scene.add(leaves);
        }
    }
    
    createGlowingMushroom(x, z) {
        const stemGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.set(x, 0.5, z);
        this.scene.add(stem);
        
        const capGeometry = new THREE.SphereGeometry(0.8, 8, 8);
        const capMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xFF69B4,
            emissive: 0xFF1493,
            emissiveIntensity: 0.5
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.set(x, 1.5, z);
        cap.scale.set(1, 0.5, 1);
        this.scene.add(cap);
        
        const light = new THREE.PointLight(0xFF1493, 1, 5);
        light.position.set(x, 1.5, z);
        this.scene.add(light);
    }
    
    createMachineStructures() {
        for (let i = 0; i < 30; i++) {
            const geometry = new THREE.BoxGeometry(2, 4, 2);
            const material = new THREE.MeshStandardMaterial({ color: 0x696969 });
            const machine = new THREE.Mesh(geometry, material);
            machine.position.set(
                (Math.random() - 0.5) * 180,
                2,
                (Math.random() - 0.5) * 180
            );
            machine.castShadow = true;
            this.scene.add(machine);
        }
    }
    
    createNeonStructures() {
        for (let i = 0; i < 40; i++) {
            const geometry = new THREE.BoxGeometry(1, 3, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xFF1493,
                emissive: 0xFF1493,
                emissiveIntensity: 0.8
            });
            const neon = new THREE.Mesh(geometry, material);
            neon.position.set(
                (Math.random() - 0.5) * 180,
                1.5,
                (Math.random() - 0.5) * 180
            );
            this.scene.add(neon);
            
            const light = new THREE.PointLight(0xFF1493, 2, 10);
            light.position.copy(neon.position);
            this.scene.add(light);
        }
    }
    
    setupSpawnPoints(stageKey) {
        const stage = this.stages[stageKey];
        stage.spawnPoints = [];
        const mapSize = 200;
        
        for (let i = 0; i < 20; i++) {
            stage.spawnPoints.push(new THREE.Vector3(
                (Math.random() - 0.5) * (mapSize - 20),
                1,
                (Math.random() - 0.5) * (mapSize - 20)
            ));
        }
    }
    
    update(deltaTime) {
    }
}

// FloatingDamageSystem - ÌîåÎ°úÌåÖ Îç∞ÎØ∏ÏßÄ Ïà´Ïûê
class FloatingDamageSystem {
    constructor() {
        this.container = document.getElementById('floatingDamageContainer');
        this.damageElements = [];
    }
    
    showDamage(worldPosition, camera, damage, isHeadshot = false) {
        // 3D ÏõîÎìú Ï¢åÌëúÎ•º 2D ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò
        const vector = worldPosition.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        
        // Îç∞ÎØ∏ÏßÄ ÏöîÏÜå ÏÉùÏÑ±
        const damageElement = document.createElement('div');
        damageElement.className = 'floating-damage' + (isHeadshot ? ' headshot' : '');
        damageElement.textContent = '-' + Math.round(damage);
        damageElement.style.left = x + 'px';
        damageElement.style.top = y + 'px';
        damageElement.style.transform = 'translate(-50%, -50%)';
        
        // ÎûúÎç§ Ïò§ÌîÑÏÖã Ï∂îÍ∞Ä
        const offsetX = (Math.random() - 0.5) * 50;
        damageElement.style.left = (x + offsetX) + 'px';
        
        this.container.appendChild(damageElement);
        this.damageElements.push(damageElement);
        
        // 1Ï¥à ÌõÑ Ï†úÍ±∞
        setTimeout(() => {
            if (damageElement.parentNode) {
                damageElement.parentNode.removeChild(damageElement);
            }
            const index = this.damageElements.indexOf(damageElement);
            if (index > -1) {
                this.damageElements.splice(index, 1);
            }
        }, 1000);
    }
}

// CameraShakeSystem - Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
class CameraShakeSystem {
    constructor(camera) {
        this.camera = camera;
        this.originalPosition = camera.position.clone();
        this.shakeIntensity = 0;
        this.shakeDecay = 0.9;
        this.isShaking = false;
    }
    
    shake(intensity = 0.1, duration = 0.3) {
        this.shakeIntensity = intensity;
        this.isShaking = true;
        
        setTimeout(() => {
            this.isShaking = false;
            this.shakeIntensity = 0;
        }, duration * 1000);
    }
    
    update(deltaTime) {
        if (this.isShaking && this.shakeIntensity > 0) {
            const offsetX = (Math.random() - 0.5) * this.shakeIntensity;
            const offsetY = (Math.random() - 0.5) * this.shakeIntensity;
            const offsetZ = (Math.random() - 0.5) * this.shakeIntensity;
            
            this.camera.position.x = this.originalPosition.x + offsetX;
            this.camera.position.y = this.originalPosition.y + offsetY;
            this.camera.position.z = this.originalPosition.z + offsetZ;
            
            this.shakeIntensity *= this.shakeDecay;
        } else {
            this.originalPosition.copy(this.camera.position);
        }
    }
}

// HitMarkerSystem - ÌûàÌä∏ ÎßàÏª§
class HitMarkerSystem {
    constructor() {
        this.marker = document.getElementById('hitMarker');
        this.isShowing = false;
    }
    
    show(isHeadshot = false) {
        if (this.isShowing) return;
        
        this.isShowing = true;
        this.marker.classList.remove('hidden');
        this.marker.style.opacity = '1';
        
        // Ìó§ÎìúÏÉ∑ Ïãú Îçî ÌÅ¨Í≤å ÌëúÏãú
        if (isHeadshot) {
            this.marker.style.width = '60px';
            this.marker.style.height = '60px';
            this.marker.querySelector('div').style.background = '#ffd700';
            this.marker.querySelectorAll('div')[1].style.background = '#ffd700';
        } else {
            this.marker.style.width = '40px';
            this.marker.style.height = '40px';
            this.marker.querySelector('div').style.background = '#ff0000';
            this.marker.querySelectorAll('div')[1].style.background = '#ff0000';
        }
        
        setTimeout(() => {
            this.marker.classList.add('hidden');
            this.isShowing = false;
        }, 200);
    }
}

// MinimapSystem - ÎØ∏ÎãàÎßµ
class MinimapSystem {
    constructor(scene, camera, tower, enemies) {
        this.scene = scene;
        this.camera = camera;
        this.tower = tower;
        this.enemies = enemies;
        this.canvas = document.getElementById('minimapCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.mapSize = 200; // Îßµ ÌÅ¨Í∏∞ (Í≤åÏûÑ ÏõîÎìú Í∏∞Ï§Ä)
        this.minimapSize = 200; // ÎØ∏ÎãàÎßµ ÌîΩÏÖÄ ÌÅ¨Í∏∞
    }
    
    update() {
        // Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶¨Ïñ¥
        this.ctx.clearRect(0, 0, this.minimapSize, this.minimapSize);
        
        // Î∞∞Í≤Ω
        this.ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
        this.ctx.fillRect(0, 0, this.minimapSize, this.minimapSize);
        
        // Îßµ Ï§ëÏã¨Ï†ê
        const centerX = this.minimapSize / 2;
        const centerY = this.minimapSize / 2;
        const scale = this.minimapSize / this.mapSize;
        
        // ÌÉÄÏõå ÌëúÏãú (Ï§ëÏïô, Îπ®Í∞ÑÏÉâ)
        if (this.tower) {
            const towerPos = this.tower.getPosition();
            const towerX = centerX + towerPos.x * scale;
            const towerY = centerY + towerPos.z * scale;
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(towerX, towerY, 5, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // ÌîåÎ†àÏù¥Ïñ¥ ÌëúÏãú (ÌååÎûÄÏÉâ)
        const playerX = centerX + this.camera.position.x * scale;
        const playerY = centerY + this.camera.position.z * scale;
        this.ctx.fillStyle = '#00ff00';
        this.ctx.beginPath();
        this.ctx.arc(playerX, playerY, 4, 0, Math.PI * 2);
        this.ctx.fill();
        
        // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ• ÌëúÏãú
        const direction = new THREE.Vector3();
        this.camera.getWorldDirection(direction);
        this.ctx.strokeStyle = '#00ff00';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(playerX, playerY);
        this.ctx.lineTo(playerX + direction.x * 10, playerY + direction.z * 10);
        this.ctx.stroke();
        
        // Ï†Å ÌëúÏãú (ÎÖ∏ÎûÄÏÉâ)
        if (this.enemies) {
            this.enemies.forEach(enemy => {
                if (!enemy.isDead && enemy.position) {
                    const enemyX = centerX + enemy.position.x * scale;
                    const enemyY = centerY + enemy.position.z * scale;
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.beginPath();
                    this.ctx.arc(enemyX, enemyY, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            });
        }
    }
}

// ShopSystem - ÏÉÅÏ†ê ÏãúÏä§ÌÖú
class ShopSystem {
    constructor(game) {
        this.game = game;
        this.shopMenu = document.getElementById('shopMenu');
        this.shopItems = document.getElementById('shopItems');
        this.closeShopBtn = document.getElementById('closeShop');
        
        this.items = [
            { id: 'damage', name: 'Îç∞ÎØ∏ÏßÄ ÏóÖÍ∑∏Î†àÏù¥Îìú', price: 200, effect: () => this.upgradeDamage() },
            { id: 'fireRate', name: 'Î∞úÏÇ¨ ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥Îìú', price: 200, effect: () => this.upgradeFireRate() },
            { id: 'ammo', name: 'ÌÉÑÏïΩ ÏóÖÍ∑∏Î†àÏù¥Îìú', price: 150, effect: () => this.upgradeAmmo() },
            { id: 'health', name: 'Ï≤¥Î†• ÌöåÎ≥µ', price: 100, effect: () => this.healPlayer() },
            { id: 'speed', name: 'Ïù¥Îèô ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥Îìú', price: 250, effect: () => this.upgradeSpeed() },
            { id: 'towerHeal', name: 'ÌÉÄÏõå Ï≤¥Î†• ÌöåÎ≥µ', price: 300, effect: () => this.healTower() },
            { id: 'turret_basic', name: 'Í∏∞Î≥∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë', price: 150, effect: () => this.buyTurret('basic') },
            { id: 'turret_rapid', name: 'Îπ†Î•∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë', price: 200, effect: () => this.buyTurret('rapid') },
            { id: 'turret_heavy', name: 'Í∞ïÎ†•Ìïú ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë', price: 300, effect: () => this.buyTurret('heavy') },
            { id: 'turret_sniper', name: 'Ï†ÄÍ≤© ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë', price: 350, effect: () => this.buyTurret('sniper') },
            { id: 'turret_splash', name: 'Î≤îÏúÑ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë', price: 400, effect: () => this.buyTurret('splash') }
        ];
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        this.closeShopBtn.addEventListener('click', () => {
            this.hide();
        });
    }
    
    show() {
        this.shopMenu.classList.remove('hidden');
        this.renderItems();
    }
    
    hide() {
        this.shopMenu.classList.add('hidden');
    }
    
    renderItems() {
        this.shopItems.innerHTML = '';
        
        this.items.forEach(item => {
            const itemElement = document.createElement('div');
            const canAfford = this.game.resourceManager.resources >= item.price;
            itemElement.style.cssText = `background: rgba(255, 255, 255, ${canAfford ? '0.1' : '0.05'}); border: 2px solid ${canAfford ? '#fff' : '#666'}; border-radius: 10px; padding: 15px; cursor: ${canAfford ? 'pointer' : 'not-allowed'}; text-align: center; opacity: ${canAfford ? '1' : '0.6'};`;
            
            // Ìè¨ÌÉë ÏïÑÏù¥ÌÖúÏù∏ Í≤ΩÏö∞ ÏÑ§Î™Ö Ï∂îÍ∞Ä
            let description = '';
            if (item.id.startsWith('turret_')) {
                const turretInfo = {
                    'turret_basic': 'Î≤îÏúÑ: 15, Îç∞ÎØ∏ÏßÄ: 20, Î∞úÏÇ¨ÏÜçÎèÑ: 1.0',
                    'turret_rapid': 'Î≤îÏúÑ: 12, Îç∞ÎØ∏ÏßÄ: 15, Î∞úÏÇ¨ÏÜçÎèÑ: 2.5',
                    'turret_heavy': 'Î≤îÏúÑ: 18, Îç∞ÎØ∏ÏßÄ: 40, Î∞úÏÇ¨ÏÜçÎèÑ: 0.6',
                    'turret_sniper': 'Î≤îÏúÑ: 25, Îç∞ÎØ∏ÏßÄ: 50, Î∞úÏÇ¨ÏÜçÎèÑ: 0.8',
                    'turret_splash': 'Î≤îÏúÑ: 14, Îç∞ÎØ∏ÏßÄ: 25, Î∞úÏÇ¨ÏÜçÎèÑ: 1.2 (Î≤îÏúÑÍ≥µÍ≤©)'
                };
                description = `<div style="font-size: 12px; color: #ccc; margin-top: 5px;">${turretInfo[item.id] || ''}</div>`;
            }
            
            itemElement.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">${item.name}</div>
                <div style="font-size: 16px; color: #ffd700;">üí∞ ${item.price}</div>
                ${description}
            `;
            
            if (canAfford) {
                itemElement.addEventListener('click', () => {
                    this.purchaseItem(item);
                });
            }
            
            this.shopItems.appendChild(itemElement);
        });
    }
    
    purchaseItem(item) {
        if (this.game.resourceManager.resources >= item.price) {
            this.game.resourceManager.spendResources(item.price);
            item.effect();
            this.game.uiManager.showStageTitle(`${item.name} Íµ¨Îß§ ÏôÑÎ£å!`);
            this.renderItems();
        } else {
            this.game.uiManager.showStageTitle('Î¶¨ÏÜåÏä§Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!');
        }
    }
    
    upgradeDamage() {
        if (this.game.weaponManager.currentWeapon) {
            this.game.weaponManager.currentWeapon.damage *= 1.2;
        }
    }
    
    upgradeFireRate() {
        if (this.game.weaponManager.currentWeapon) {
            this.game.weaponManager.currentWeapon.fireRate *= 0.9;
        }
    }
    
    upgradeAmmo() {
        if (this.game.weaponManager.currentWeapon) {
            this.game.weaponManager.currentWeapon.maxAmmo = Math.floor(this.game.weaponManager.currentWeapon.maxAmmo * 1.3);
            this.game.weaponManager.currentWeapon.currentAmmo = this.game.weaponManager.currentWeapon.maxAmmo;
            this.game.uiManager.updateAmmo(this.game.weaponManager.currentWeapon.currentAmmo, this.game.weaponManager.currentWeapon.maxAmmo);
        }
    }
    
    healPlayer() {
        this.game.player.currentHealth = this.game.player.maxHealth;
        this.game.uiManager.updateHealth(this.game.player.currentHealth, this.game.player.maxHealth);
    }
    
    upgradeSpeed() {
        this.game.player.speed *= 1.15;
        this.game.player.runSpeed *= 1.15;
    }
    
    healTower() {
        if (this.game.tower) {
            this.game.tower.currentHealth = Math.min(this.game.tower.currentHealth + 200, this.game.tower.maxHealth);
            this.game.uiManager.updateTowerHealth(this.game.tower.currentHealth, this.game.tower.maxHealth);
        }
    }
    
    buyTurret(type) {
        // Ìè¨ÌÉëÏùÄ ÏÉÅÏ†êÏóêÏÑú Íµ¨Îß§ÌïòÎ©¥ Î∞îÎ°ú ÏÑ§ÏπòÎê®
        const turretCosts = {
            'basic': 150,
            'rapid': 200,
            'heavy': 300,
            'sniper': 350,
            'splash': 400
        };
        
        const cost = turretCosts[type] || 150;
        
        if (this.game.resourceManager.resources >= cost) {
            this.game.resourceManager.spendResources(cost);
            // ÌîåÎ†àÏù¥Ïñ¥ ÏïûÏóê Ìè¨ÌÉë ÏÑ§Ïπò
            const camera = this.game.camera;
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const turretPosition = camera.position.clone();
            turretPosition.add(direction.multiplyScalar(5));
            turretPosition.y = 0;
            
            // Ìè¨ÌÉë ÏÉùÏÑ±
            const turret = new TurretBase(this.game.scene, turretPosition, type);
            this.game.turrets.push(turret);
            
            const typeNames = {
                'basic': 'Í∏∞Î≥∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
                'rapid': 'Îπ†Î•∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
                'heavy': 'Í∞ïÎ†•Ìïú ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
                'sniper': 'Ï†ÄÍ≤© ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
                'splash': 'Î≤îÏúÑ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë'
            };
            
            this.game.uiManager.showStageTitle(typeNames[type] + ' ÏÑ§Ïπò ÏôÑÎ£å!');
            this.renderItems(); // ÏÉÅÏ†ê ÏïÑÏù¥ÌÖú ÏóÖÎç∞Ïù¥Ìä∏
        } else {
            this.game.uiManager.showStageTitle('Î¶¨ÏÜåÏä§Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!');
        }
    }
}

// ParticleSystem
class ParticleSystem {
    constructor(scene) {
        this.scene = scene;
        this.particles = [];
    }
    
    createExplosion(position, color = 0xff6b6b, count = 20) {
        for (let i = 0; i < count; i++) {
            const geometry = new THREE.SphereGeometry(0.1, 4, 4);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.copy(position);
            this.scene.add(particle);
            
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
            
            this.particles.push({
                mesh: particle,
                velocity: velocity,
                life: 1.0,
                decay: 0.02 + Math.random() * 0.03
            });
        }
    }
    
    createSpark(position, direction) {
        const geometry = new THREE.SphereGeometry(0.05, 4, 4);
        const material = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const spark = new THREE.Mesh(geometry, material);
        spark.position.copy(position);
        this.scene.add(spark);
        
        const velocity = direction.clone().multiplyScalar(-0.5).add(
            new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            )
        );
        
        this.particles.push({
            mesh: spark,
            velocity: velocity,
            life: 0.5,
            decay: 0.05
        });
    }
    
    update(deltaTime) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            particle.life -= particle.decay;
            
            if (particle.life <= 0) {
                this.scene.remove(particle.mesh);
                particle.mesh.geometry.dispose();
                particle.mesh.material.dispose();
                this.particles.splice(i, 1);
                continue;
            }
            
            particle.mesh.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
            particle.velocity.multiplyScalar(0.95); // Ï†ÄÌï≠
            particle.mesh.material.opacity = particle.life;
            particle.mesh.scale.multiplyScalar(0.98);
        }
    }
}

// ScoreManager
class ScoreManager {
    constructor() {
        this.score = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.comboTimeLimit = 3; // 3Ï¥à ÎÇ¥Ïóê ÌÇ¨Ìï¥Ïïº ÏΩ§Î≥¥ Ïú†ÏßÄ
        this.lastKillTime = 0;
    }
    
    addScore(points, isHeadshot = false) {
        const now = Date.now() / 1000;
        
        // ÏΩ§Î≥¥ Ï≤¥ÌÅ¨
        if (now - this.lastKillTime < this.comboTimeLimit) {
            this.combo++;
        } else {
            this.combo = 1;
        }
        
        this.lastKillTime = now;
        
        // Ï†êÏàò Í≥ÑÏÇ∞ (ÏΩ§Î≥¥ Î≥¥ÎÑàÏä§)
        let finalPoints = points;
        if (isHeadshot) {
            finalPoints *= 2; // Ìó§ÎìúÏÉ∑ Î≥¥ÎÑàÏä§
        }
        finalPoints *= (1 + this.combo * 0.1); // ÏΩ§Î≥¥ Î≥¥ÎÑàÏä§
        
        this.score += Math.round(finalPoints);
        
        return {
            points: Math.round(finalPoints),
            combo: this.combo,
            isHeadshot: isHeadshot
        };
    }
    
    update(deltaTime) {
        const now = Date.now() / 1000;
        if (now - this.lastKillTime > this.comboTimeLimit) {
            this.combo = 0;
        }
    }
    
    reset() {
        this.score = 0;
        this.combo = 0;
        this.lastKillTime = 0;
    }
}

// UIManager
class UIManager {
    constructor() {
        this.elements = {
            healthBar: document.getElementById('healthBarFill'),
            healthText: document.getElementById('healthText'),
            ammoCount: document.getElementById('ammoCount'),
            weaponName: document.getElementById('weaponName'),
            sugarBar: document.getElementById('sugarBarFill'),
            sugarText: document.getElementById('sugarText'),
            stageTitle: document.getElementById('stageTitle'),
            interactionPrompt: document.getElementById('interactionPrompt'),
            dialogueBox: document.getElementById('dialogueBox'),
            dialogueText: document.getElementById('dialogueText'),
            lowHealthVignette: document.getElementById('lowHealthVignette'),
            sugarRushOverlay: document.getElementById('sugarRushOverlay'),
            scoreValue: document.getElementById('scoreValue'),
            comboDisplay: document.getElementById('comboDisplay'),
            comboValue: document.getElementById('comboValue'),
            bossHealthBar: document.getElementById('bossHealthBar'),
            bossHealthFill: document.getElementById('bossHealthFill'),
            bossHealthText: document.getElementById('bossHealthText')
        };
    }
    
    updateHealth(current, max) {
        const percent = (current / max) * 100;
        this.elements.healthBar.style.width = percent + '%';
        this.elements.healthText.textContent = `${current} / ${max}`;
        
        if (percent < 30) {
            this.elements.lowHealthVignette.classList.remove('hidden');
        } else {
            this.elements.lowHealthVignette.classList.add('hidden');
        }
    }
    
    updateAmmo(current, max) {
        this.elements.ammoCount.textContent = `${current} / ${max}`;
    }
    
    updateWeaponName(name) {
        this.elements.weaponName.textContent = name;
    }
    
    updateSugarMeter(current, max) {
        const percent = (current / max) * 100;
        this.elements.sugarBar.style.width = percent + '%';
        this.elements.sugarText.textContent = Math.round(percent) + '%';
    }
    
    showStageTitle(stageName) {
        this.elements.stageTitle.textContent = stageName;
        this.elements.stageTitle.style.display = 'block';
        
        setTimeout(() => {
            this.elements.stageTitle.style.display = 'none';
        }, 3000);
    }
    
    showInteractionPrompt(text = 'Press E to interact') {
        this.elements.interactionPrompt.textContent = text;
        this.elements.interactionPrompt.classList.remove('hidden');
    }
    
    hideInteractionPrompt() {
        this.elements.interactionPrompt.classList.add('hidden');
    }
    
    showDialogue(text) {
        this.elements.dialogueText.textContent = text;
        this.elements.dialogueBox.classList.remove('hidden');
    }
    
    hideDialogue() {
        this.elements.dialogueBox.classList.add('hidden');
    }
    
    toggleSugarRushOverlay(active) {
        if (active) {
            this.elements.sugarRushOverlay.classList.remove('hidden');
        } else {
            this.elements.sugarRushOverlay.classList.add('hidden');
        }
    }
    
    updateScore(score) {
        this.elements.scoreValue.textContent = score.toLocaleString();
    }
    
    updateCombo(combo, isHeadshot = false) {
        if (combo > 1) {
            this.elements.comboDisplay.style.display = 'block';
            this.elements.comboValue.textContent = combo;
            if (isHeadshot) {
                this.elements.comboDisplay.style.color = '#ff0000';
                this.elements.comboDisplay.textContent = `HEADSHOT! Combo x${combo}!`;
            } else {
                this.elements.comboDisplay.style.color = '#ffd700';
                this.elements.comboDisplay.textContent = `Combo x${combo}!`;
            }
            
            // ÏΩ§Î≥¥ Ìö®Í≥º Ïï†ÎãàÎ©îÏù¥ÏÖò
            this.elements.comboDisplay.classList.add('combo-effect');
            setTimeout(() => {
                this.elements.comboDisplay.classList.remove('combo-effect');
            }, 500);
        } else {
            this.elements.comboDisplay.style.display = 'none';
        }
    }
    
    showBossHealth(current, max) {
        this.elements.bossHealthBar.classList.remove('hidden');
        const percent = (current / max) * 100;
        this.elements.bossHealthFill.style.width = percent + '%';
        this.elements.bossHealthText.textContent = Math.round(percent) + '%';
    }
    
    hideBossHealth() {
        this.elements.bossHealthBar.classList.add('hidden');
    }
    
    updateTowerHealth(current, max) {
        let towerHealthBar = document.getElementById('towerHealthBar');
        if (!towerHealthBar) {
            towerHealthBar = document.createElement('div');
            towerHealthBar.id = 'towerHealthBar';
            towerHealthBar.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); width: 300px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 1000;';
            towerHealthBar.innerHTML = '<div style="color: white; margin-bottom: 5px;">ÎèÑÌÜ†Î¶¨ ÌÉÄÏõå</div><div style="background: #333; height: 20px; border-radius: 3px; overflow: hidden;"><div id="towerHealthBarFill" style="background: #4CAF50; height: 100%; width: 100%; transition: width 0.3s;"></div></div><div id="towerHealthText" style="color: white; margin-top: 5px; text-align: center;"></div>';
            document.body.appendChild(towerHealthBar);
        }
        const percent = (current / max) * 100;
        const fill = document.getElementById('towerHealthBarFill');
        const text = document.getElementById('towerHealthText');
        if (fill) {
            fill.style.width = percent + '%';
            if (percent < 30) fill.style.background = '#f44336';
            else if (percent < 60) fill.style.background = '#ff9800';
            else fill.style.background = '#4CAF50';
        }
        if (text) text.textContent = `${Math.round(current)} / ${max}`;
    }
    
    updateResources(resources) {
        let resourceDisplay = document.getElementById('resourceDisplay');
        if (!resourceDisplay) {
            resourceDisplay = document.createElement('div');
            resourceDisplay.id = 'resourceDisplay';
            resourceDisplay.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 1000; color: #ffd700; font-size: 20px; font-weight: bold;';
            resourceDisplay.innerHTML = 'üí∞ <span id="resourceValue">0</span>';
            document.body.appendChild(resourceDisplay);
        }
        const resourceValue = document.getElementById('resourceValue');
        if (resourceValue) resourceValue.textContent = resources;
    }
}

// SoundManager
class SoundManager {
    constructor() {
        this.sounds = {};
        this.music = {};
        this.currentMusic = null;
        this.musicVolume = 0.5;
        this.sfxVolume = 0.7;
        
        this.init();
    }
    
    init() {
        this.sounds = {
            shoot: this.createAudio('sounds/shoot.mp3'),
            reload: this.createAudio('sounds/reload.mp3'),
            enemyDeath: this.createAudio('sounds/enemyDeath.mp3'),
            playerHit: this.createAudio('sounds/playerHit.mp3'),
            pickup: this.createAudio('sounds/pickup.mp3'),
            sugarRush: this.createAudio('sounds/sugarRush.mp3'),
            melee: this.createAudio('sounds/melee.mp3')
        };
        
        this.music = {
            mossyMeadow: this.createAudio('music/mossyMeadow.mp3', true),
            shroomHollow: this.createAudio('music/shroomHollow.mp3', true),
            wreckedFactory: this.createAudio('music/wreckedFactory.mp3', true),
            trashTown: this.createAudio('music/trashTown.mp3', true),
            boss: this.createAudio('music/boss.mp3', true)
        };
        
        Object.values(this.music).forEach(audio => {
            audio.volume = this.musicVolume;
            audio.loop = true;
        });
        
        Object.values(this.sounds).forEach(audio => {
            audio.volume = this.sfxVolume;
        });
    }
    
    createAudio(src, isMusic = false) {
        const audio = new Audio();
        audio.src = src;
        audio.loop = isMusic;
        
        // Ïò§ÎîîÏò§ Î°úÎî© Ïã§Ìå® Ïãú Ï°∞Ïö©Ìûà Ï≤òÎ¶¨ (ÌååÏùºÏù¥ ÏóÜÏñ¥ÎèÑ Í≤åÏûÑÏùÄ Í≥ÑÏÜç ÏûëÎèô)
        audio.addEventListener('error', (e) => {
            // Ïò§Î•òÎ•º ÏΩòÏÜîÏóê ÌëúÏãúÌïòÏßÄ ÏïäÏùå (ÌååÏùºÏù¥ ÏóÜÏñ¥ÎèÑ Í≤åÏûÑÏùÄ Ï†ïÏÉÅ ÏûëÎèô)
            // console.log('Audio file not found (optional):', src);
        }, { once: true });
        
        // Ïò§ÎîîÏò§ Î°úÎî© ÏãúÎèÑ (load()Îäî PromiseÎ•º Î∞òÌôòÌïòÏßÄ ÏïäÏúºÎØÄÎ°ú catch ÏÇ¨Ïö© Ïïà Ìï®)
        try {
            audio.load();
        } catch (e) {
            // Ï°∞Ïö©Ìûà Ïã§Ìå® Ï≤òÎ¶¨
        }
        
        return audio;
    }
    
    play(soundName) {
        const sound = this.sounds[soundName];
        if (sound) {
            sound.currentTime = 0;
            // ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù Ïã§Ìå® Ïãú Ï°∞Ïö©Ìûà Ï≤òÎ¶¨ (ÌååÏùºÏù¥ ÏóÜÏñ¥ÎèÑ Í≤åÏûÑÏùÄ Í≥ÑÏÜç ÏûëÎèô)
            sound.play().catch(() => {
                // Ï°∞Ïö©Ìûà Ïã§Ìå® Ï≤òÎ¶¨
            });
        }
    }
    
    playStageMusic(stageName) {
        if (this.currentMusic) {
            this.currentMusic.pause();
            this.currentMusic.currentTime = 0;
        }
        
        const music = this.music[stageName];
        if (music) {
            this.currentMusic = music;
            // ÏùåÏïÖ Ïû¨ÏÉù Ïã§Ìå® Ïãú Ï°∞Ïö©Ìûà Ï≤òÎ¶¨ (ÌååÏùºÏù¥ ÏóÜÏñ¥ÎèÑ Í≤åÏûÑÏùÄ Í≥ÑÏÜç ÏûëÎèô)
            music.play().catch(() => {
                // Ï°∞Ïö©Ìûà Ïã§Ìå® Ï≤òÎ¶¨
            });
        }
    }
    
    playBossMusic() {
        this.playStageMusic('boss');
    }
    
    stopMusic() {
        if (this.currentMusic) {
            this.currentMusic.pause();
            this.currentMusic.currentTime = 0;
            this.currentMusic = null;
        }
    }
    
    setMusicVolume(volume) {
        this.musicVolume = volume;
        Object.values(this.music).forEach(audio => {
            audio.volume = volume;
        });
    }
    
    setSFXVolume(volume) {
        this.sfxVolume = volume;
        Object.values(this.sounds).forEach(audio => {
            audio.volume = volume;
        });
    }
}

// PlayerController
class PlayerController {
    constructor(camera, scene) {
        this.camera = camera;
        this.scene = scene;
        this.inputManager = new InputManager();
        
        this.speed = 8;
        this.runSpeed = 12;
        this.jumpHeight = 8;
        this.gravity = -25;
        this.dashDistance = 5;
        this.dashCooldown = 1;
        this.dashTimer = 0;
        
        this.velocity = new THREE.Vector3();
        this.isGrounded = true;
        this.isRunning = false;
        this.isCrouching = false;
        this.jumpPressed = false;
        this.jumpCooldown = 0;
        this.lastJumpTime = 0;
        
        this.mouseSensitivity = 0.001;
        this.verticalRotation = 0;
        this.maxVerticalAngle = Math.PI / 2 - 0.1;
        
        this.cameraBobAmount = 0.05;
        this.cameraBobSpeed = 10;
        this.cameraBobTimer = 0;
        this.originalCameraY = camera.position.y;
        
        this.trashSenseRange = 10;
        this.trashSenseActive = false;
        
        this.maxHealth = 100;
        this.currentHealth = 100;
        this.sugarMeter = 0;
        this.maxSugarMeter = 100;
        
        this.collidableObjects = [];
        this.playerRadius = 0.3;
        this.collisionEnabled = false; // Ï∂©Îèå Í∞êÏßÄ ÏùºÏãú ÎπÑÌôúÏÑ±Ìôî (Ïù¥Îèô Î¨∏Ï†ú Ìï¥Í≤∞ ÌõÑ Ïû¨ÌôúÏÑ±Ìôî)
        
        this.onHealthChanged = null;
        this.onSugarRushToggle = null;
        
        this.setupControls();
    }
    
    setupControls() {
        const canvas = document.getElementById('gameCanvas');
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });
        
        // Space ÌÇ§ ÏßÅÏ†ë Î¶¨Ïä§ÎÑà - ÏôÑÏ†ÑÌûà ÏÉàÎ°úÏö¥ Î∞©Ïãù
        const self = this;
        
        // Ï†ÑÏó≠ ÌÇ§ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ - Space ÌÇ§Îßå Ï≤òÎ¶¨
        this._globalJumpHandler = (e) => {
            const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Space' || e.keyCode === 32;
            if (isSpace) {
                // Space ÌÇ§Îßå preventDefault (Îã§Î•∏ ÌÇ§Îäî Î∞©Ìï¥ÌïòÏßÄ ÏïäÏùå)
                e.preventDefault();
                
                const now = Date.now();
                const timeSinceLastJump = now - self.lastJumpTime;
                
                // Ï†êÌîÑ Ï°∞Í±¥ - Îß§Ïö∞ Í¥ÄÎåÄÌïòÍ≤å
                const canJump = (self.isGrounded || self.camera.position.y <= 1.7) && 
                               !self.isCrouching && 
                               timeSinceLastJump > 150;
                
                if (canJump) {
                    self.velocity.y = self.jumpHeight;
                    self.isGrounded = false;
                    self.jumpCooldown = 0.2;
                    self.lastJumpTime = now;
                    self.jumpPressed = true;
                }
            }
            // Îã§Î•∏ ÌÇ§Îäî Í∑∏ÎåÄÎ°ú ÌÜµÍ≥ºÏãúÌÇ¥ (WASD Îì±)
        };
        
        this._globalJumpUpHandler = (e) => {
            const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Space' || e.keyCode === 32;
            if (isSpace) {
                self.jumpPressed = false;
            }
        };
        
        // ÏµúÏö∞ÏÑ†ÏúºÎ°ú Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
        window.addEventListener('keydown', this._globalJumpHandler, {capture: true, passive: false});
        document.addEventListener('keydown', this._globalJumpHandler, {capture: true, passive: false});
        window.addEventListener('keyup', this._globalJumpUpHandler, {capture: true, passive: false});
    }
    
    setCollidableObjects(objects) {
        this.collidableObjects = objects;
    }
    
    update(deltaTime) {
        this.handleMouseLook();
        this.handleJump(deltaTime); // Ï†êÌîÑÎ•º Î®ºÏ†Ä Ï≤òÎ¶¨
        this.handleMovement(deltaTime);
        this.handleDash(deltaTime);
        this.handleCrouch();
        this.handleTrashSense();
        this.applyGravity(deltaTime);
        this.updateCameraBob(deltaTime);
        this.checkGround();
    }
    
    handleMouseLook() {
        const mouseDelta = this.inputManager.getMouseDelta();
        
        // Three.js Euler ÌöåÏ†Ñ ÏàúÏÑúÎ•º 'YXZ'Î°ú ÏÑ§Ï†ïÌïòÏó¨ ÏàòÌèâ/ÏàòÏßÅ ÌöåÏ†ÑÏùÑ ÏôÑÏ†ÑÌûà Î∂ÑÎ¶¨
        // Ïù¥Î†áÍ≤å ÌïòÎ©¥ YÏ∂ï ÌöåÏ†Ñ(ÏàòÌèâ)Ïù¥ XÏ∂ï ÌöåÏ†Ñ(ÏàòÏßÅ)Ïóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÏùå
        this.camera.rotation.order = 'YXZ';
        
        // ÏàòÌèâ ÌöåÏ†Ñ (YÏ∂ï) - Ï¢åÏö∞Îßå Ï≤òÎ¶¨ (ÏàòÏßÅ ÌöåÏ†ÑÍ≥º ÏôÑÏ†ÑÌûà ÎèÖÎ¶ΩÏ†Å)
        if (mouseDelta.x !== 0) {
            this.camera.rotation.y -= mouseDelta.x * this.mouseSensitivity;
        }
        
        // ÏàòÏßÅ ÌöåÏ†Ñ (XÏ∂ï) - ÏÉÅÌïòÎßå Ï≤òÎ¶¨ (ÏàòÌèâ ÌöåÏ†ÑÍ≥º ÏôÑÏ†ÑÌûà ÎèÖÎ¶ΩÏ†Å)
        if (mouseDelta.y !== 0) {
            this.verticalRotation -= mouseDelta.y * this.mouseSensitivity;
            this.verticalRotation = Math.max(-this.maxVerticalAngle, 
                                            Math.min(this.maxVerticalAngle, this.verticalRotation));
            // XÏ∂ï ÌöåÏ†ÑÎßå ÏóÖÎç∞Ïù¥Ìä∏ (YÏ∂ï ÌöåÏ†ÑÏùÄ Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå)
            this.camera.rotation.x = this.verticalRotation;
        }
        
        // ZÏ∂ï ÌöåÏ†ÑÏùÄ Ìï≠ÏÉÅ 0ÏúºÎ°ú Ïú†ÏßÄ (Î°§ Î∞©ÏßÄ)
        this.camera.rotation.z = 0;
    }
    
    handleMovement(deltaTime) {
        this.isRunning = this.inputManager.isKeyPressed('ShiftLeft');
        const speed = this.isRunning ? this.runSpeed : this.speed;
        
        const direction = new THREE.Vector3();
        let hasInput = false;
        
        // WASD ÌÇ§ ÏûÖÎ†• ÌôïÏù∏ (Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï≤¥ÌÅ¨)
        const wPressed = this.inputManager.isKeyPressed('KeyW');
        const sPressed = this.inputManager.isKeyPressed('KeyS');
        const aPressed = this.inputManager.isKeyPressed('KeyA');
        const dPressed = this.inputManager.isKeyPressed('KeyD');
        
        if (wPressed) {
            direction.z -= 1;
            hasInput = true;
        }
        if (sPressed) {
            direction.z += 1;
            hasInput = true;
        }
        if (aPressed) {
            direction.x -= 1;
            hasInput = true;
        }
        if (dPressed) {
            direction.x += 1;
            hasInput = true;
        }
        
        // ÎîîÎ≤ÑÍπÖ: ÌÇ§ ÏûÖÎ†• ÏÉÅÌÉú ÌôïÏù∏ (ÎÑàÎ¨¥ ÎßéÏùÄ Î°úÍ∑∏ Î∞©ÏßÄ)
        // if (wPressed || sPressed || aPressed || dPressed) {
        //     console.log('WASD pressed:', {w: wPressed, s: sPressed, a: aPressed, d: dPressed, hasInput});
        // }
        
        if (!hasInput) {
            // ÏûÖÎ†•Ïù¥ ÏóÜÏúºÎ©¥ ÏÜçÎèÑÎ•º Ï†êÏßÑÏ†ÅÏúºÎ°ú Í∞êÏÜå
            this.velocity.x *= 0.9;
            this.velocity.z *= 0.9;
            
            // ÏÜçÎèÑÍ∞Ä Í±∞Ïùò 0Ïù¥Î©¥ ÏôÑÏ†ÑÌûà Î©àÏ∂§
            if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;
            if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;
            
            // Í∞êÏÜåÎêú ÏÜçÎèÑÎ°ú Ïù¥Îèô (Ï∂©Îèå Ï≤¥ÌÅ¨ Ìè¨Ìï®)
            if (this.velocity.x !== 0 || this.velocity.z !== 0) {
                const newX = this.camera.position.x + this.velocity.x * deltaTime;
                const newZ = this.camera.position.z + this.velocity.z * deltaTime;
                
                // Ï∂©Îèå Ï≤¥ÌÅ¨
                if (this.collisionEnabled && this.collidableObjects.length > 0) {
                    if (!this.checkCollision(newX, this.camera.position.y, this.camera.position.z)) {
                        this.camera.position.x = newX;
                    } else {
                        this.velocity.x = 0;
                    }
                    if (!this.checkCollision(this.camera.position.x, this.camera.position.y, newZ)) {
                        this.camera.position.z = newZ;
                    } else {
                        this.velocity.z = 0;
                    }
                } else {
                    this.camera.position.x = newX;
                    this.camera.position.z = newZ;
                }
            }
            return;
        }
        
        // directionÏù¥ 0Ïù¥ ÏïÑÎãê ÎïåÎßå normalize
        const dirLength = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
        if (dirLength > 0.01) {
            direction.normalize();
        } else {
            return; // ÏûÖÎ†•Ïù¥ ÏóÜÏúºÎ©¥ Ï¢ÖÎ£å
        }
        
        const cameraDirection = new THREE.Vector3();
        this.camera.getWorldDirection(cameraDirection);
        cameraDirection.y = 0;
        cameraDirection.normalize();
        
        const right = new THREE.Vector3();
        right.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
        
        const moveDirection = new THREE.Vector3();
        moveDirection.addScaledVector(cameraDirection, -direction.z);
        moveDirection.addScaledVector(right, direction.x);
        moveDirection.normalize();
        
        this.velocity.x = moveDirection.x * speed;
        this.velocity.z = moveDirection.z * speed;
        
        // Ïù¥Îèô Ï†ÅÏö© - Ï∂©Îèå Ï≤¥ÌÅ¨ Ìè¨Ìï®
        const newX = this.camera.position.x + this.velocity.x * deltaTime;
        const newZ = this.camera.position.z + this.velocity.z * deltaTime;
        
        // ÎîîÎ≤ÑÍπÖ: Ïù¥Îèô Ï†ïÎ≥¥ ÌôïÏù∏
        // console.log('Movement:', {
        //     velocity: {x: this.velocity.x, z: this.velocity.z},
        //     moveDirection: {x: moveDirection.x, z: moveDirection.z},
        //     speed: speed,
        //     deltaTime: deltaTime,
        //     newPos: {x: newX, z: newZ},
        //     currentPos: {x: this.camera.position.x, z: this.camera.position.z}
        // });
        
        // Ï∂©Îèå Ï≤¥ÌÅ¨ (ÏùºÏãú ÎπÑÌôúÏÑ±Ìôî)
        // TODO: Ï∂©Îèå Í∞êÏßÄ Î°úÏßÅ Í∞úÏÑ† ÌõÑ Ïû¨ÌôúÏÑ±Ìôî
        // if (this.collisionEnabled && this.collidableObjects.length > 0) {
        //     // XÏ∂ï Ïù¥Îèô Ï≤¥ÌÅ¨
        //     const xCollision = this.checkCollision(newX, this.camera.position.y, this.camera.position.z);
        //     if (!xCollision) {
        //         this.camera.position.x = newX;
        //     } else {
        //         this.velocity.x = 0; // Ï∂©Îèå Ïãú Î©àÏ∂§
        //     }
        //     
        //     // ZÏ∂ï Ïù¥Îèô Ï≤¥ÌÅ¨
        //     const zCollision = this.checkCollision(this.camera.position.x, this.camera.position.y, newZ);
        //     if (!zCollision) {
        //         this.camera.position.z = newZ;
        //     } else {
        //         this.velocity.z = 0; // Ï∂©Îèå Ïãú Î©àÏ∂§
        //     }
        // } else {
        //     // Ï∂©Îèå Í∞êÏßÄ ÎπÑÌôúÏÑ±Ìôî Ïãú Î∞îÎ°ú Ïù¥Îèô
        //     this.camera.position.x = newX;
        //     this.camera.position.z = newZ;
        // }
        
        // ÏùºÏãúÏ†ÅÏúºÎ°ú Ï∂©Îèå Ï≤¥ÌÅ¨ ÏóÜÏù¥ Î∞îÎ°ú Ïù¥Îèô
        this.camera.position.x = newX;
        this.camera.position.z = newZ;
        
        // Îßµ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (Î≤Ω ÌÜµÍ≥º Î∞©ÏßÄ) - Îßµ ÌÅ¨Í∏∞ 200 Í∏∞Ï§Ä
        const mapSize = 100; // Îßµ ÌÅ¨Í∏∞Ïùò Ï†àÎ∞ò (200/2)
        if (Math.abs(this.camera.position.x) > mapSize) {
            this.camera.position.x = Math.sign(this.camera.position.x) * mapSize;
            this.velocity.x = 0;
        }
        if (Math.abs(this.camera.position.z) > mapSize) {
            this.camera.position.z = Math.sign(this.camera.position.z) * mapSize;
            this.velocity.z = 0;
        }
    }
    
    checkCollision(x, y, z) {
        if (!this.collisionEnabled || this.collidableObjects.length === 0) {
            return false; // Ï∂©Îèå Í∞êÏßÄ ÎπÑÌôúÏÑ±Ìôî ÎòêÎäî Ïò§Î∏åÏ†ùÌä∏ ÏóÜÏùå
        }
        
        const playerPos = new THREE.Vector3(x, y, z);
        
        for (let obj of this.collidableObjects) {
            if (!obj || !obj.position || !obj.geometry) continue;
            
            try {
                // ÏõîÎìú Ï¢åÌëúÎ°ú Î≥ÄÌôò
                const objWorldPos = new THREE.Vector3();
                obj.getWorldPosition(objWorldPos);
                
                // YÏ∂ïÏùÄ Î¨¥ÏãúÌïòÍ≥† XZ ÌèâÎ©¥ÏóêÏÑúÎßå Ï≤¥ÌÅ¨
                const playerXZ = new THREE.Vector2(x, z);
                const objXZ = new THREE.Vector2(objWorldPos.x, objWorldPos.z);
                const distance = playerXZ.distanceTo(objXZ);
                
                // Í∞ÑÎã®Ìïú ÏõêÌòï Ï∂©Îèå Ï≤¥ÌÅ¨
                let objRadius = 1;
                if (obj.geometry.type === 'BoxGeometry') {
                    const params = obj.geometry.parameters || {};
                    objRadius = Math.max(
                        (params.width || 1) * (obj.scale?.x || 1),
                        (params.depth || 1) * (obj.scale?.z || 1)
                    ) / 2;
                } else if (obj.geometry.type === 'CylinderGeometry') {
                    const params = obj.geometry.parameters || {};
                    objRadius = Math.max(
                        (params.radiusTop || params.radius || 1) * (obj.scale?.x || 1),
                        (params.radius || 1) * (obj.scale?.x || 1)
                    );
                } else if (obj.geometry.type === 'ConeGeometry') {
                    const params = obj.geometry.parameters || {};
                    objRadius = (params.radius || 1) * (obj.scale?.x || 1);
                } else if (obj.geometry.type === 'DodecahedronGeometry') {
                    const params = obj.geometry.parameters || {};
                    objRadius = (params.radius || 0.3) * (obj.scale?.x || 1);
                }
                
                // Ï∂©Îèå Í±∞Î¶¨ Í≥ÑÏÇ∞ (ÌîåÎ†àÏù¥Ïñ¥ Î∞òÏßÄÎ¶Ñ + Ïò§Î∏åÏ†ùÌä∏ Î∞òÏßÄÎ¶Ñ + Ïó¨Ïú† Í≥µÍ∞Ñ)
                const collisionDistance = this.playerRadius + objRadius + 0.3;
                if (distance < collisionDistance) {
                    return true;
                }
            } catch (e) {
                // Ïò§Î•ò Î∞úÏÉù Ïãú Ìï¥Îãπ Ïò§Î∏åÏ†ùÌä∏ Ïä§ÌÇµ
                continue;
            }
        }
        return false;
    }
    
    handleJump(deltaTime) {
        this.jumpCooldown -= deltaTime;
        
        // InputManagerÎ•º ÌÜµÌïú Ï†êÌîÑÎèÑ Ï≤¥ÌÅ¨
        const spaceFromInput = (this.inputManager && (
            this.inputManager.isKeyPressed('Space') || 
            this.inputManager.isKeyPressed(' ') ||
            (this.inputManager.keys && (this.inputManager.keys['Space'] || this.inputManager.keys[' ']))
        ));
        
        if (spaceFromInput || this.jumpPressed) {
            const now = Date.now();
            const timeSinceLastJump = now - this.lastJumpTime;
            const canJump = (this.isGrounded || this.camera.position.y <= 1.7) && 
                           !this.isCrouching && 
                           timeSinceLastJump > 150;
            
            if (canJump) {
                this.velocity.y = this.jumpHeight;
                this.isGrounded = false;
                this.jumpCooldown = 0.2;
                this.lastJumpTime = now;
                this.jumpPressed = false;
                console.log('=== JUMP FROM HANDLEJUMP ===', this.velocity.y);
            }
        }
    }
    
    handleDash(deltaTime) {
        this.dashTimer -= deltaTime;
        
        if (this.inputManager.isKeyPressed('KeyQ') && this.dashTimer <= 0) {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            this.camera.position.addScaledVector(direction, this.dashDistance);
            this.dashTimer = this.dashCooldown;
        }
    }
    
    handleCrouch() {
        // Ï†êÌîÑ Ï§ëÏù¥Î©¥ ÏïâÍ∏∞ Î¨¥Ïãú
        if (!this.isGrounded && this.velocity.y > 0) {
            return;
        }
        
        const wasCrouching = this.isCrouching;
        if (this.inputManager.isKeyPressed('ControlLeft')) {
            this.isCrouching = true;
            if (!wasCrouching && this.isGrounded) {
                this.camera.position.y = this.originalCameraY * 0.5;
            }
        } else {
            this.isCrouching = false;
            if (wasCrouching && this.isGrounded) {
                this.camera.position.y = this.originalCameraY;
            }
        }
    }
    
    handleTrashSense() {
        this.trashSenseActive = this.inputManager.isKeyPressed('Tab');
    }
    
    applyGravity(deltaTime) {
        // Ìï≠ÏÉÅ Ï§ëÎ†• Ï†ÅÏö©
        this.velocity.y += this.gravity * deltaTime;
        
        this.camera.position.y += this.velocity.y * deltaTime;
        
        // Î∞îÎã• ÎÜíÏù¥ Ï≤¥ÌÅ¨ - velocity.yÍ∞Ä ÏñëÏàòÎ©¥(Ï†êÌîÑ Ï§ë) Ï≤¥ÌÅ¨ ÏïàÌï®
        const groundHeight = 1.6;
        const tolerance = 0.1;
        
        // ÏïÑÎûòÎ°ú Îñ®Ïñ¥ÏßÄÍ≥† ÏûàÏùÑ ÎïåÎßå Î∞îÎã• Ï≤¥ÌÅ¨
        if (this.velocity.y <= 0 && this.camera.position.y <= groundHeight + tolerance) {
            // Î∞îÎã•Ïóê ÎãøÏïòÍ±∞ÎÇò Î∞îÎã• ÏïÑÎûòÎ°ú Îñ®Ïñ¥Ï°åÏùÑ Îïå
            if (this.camera.position.y < groundHeight) {
                this.camera.position.y = groundHeight;
            }
            
            // ÏïÑÎûòÎ°ú Îñ®Ïñ¥ÏßÄÍ≥† ÏûàÏúºÎ©¥ Ï∞©ÏßÄ
            if (this.velocity.y <= 0) {
                this.velocity.y = 0;
                this.isGrounded = true;
            }
        } else if (this.velocity.y > 0) {
            // ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÍ≥† ÏûàÏúºÎ©¥ (Ï†êÌîÑ Ï§ë)
            this.isGrounded = false;
        } else {
            // Í≥µÏ§ëÏóê ÏûàÏúºÎ©¥
            this.isGrounded = false;
        }
    }
    
    checkGround() {
        // Í∞ÑÎã®Ìïú ÎÜíÏù¥ Ï≤¥ÌÅ¨Î°ú Ï∂©Î∂Ñ
        // applyGravityÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®
    }
    
    updateCameraBob(deltaTime) {
        // Ï†êÌîÑ Ï§ëÏù¥Î©¥ Ïπ¥Î©îÎùº Î∞• Î¨¥Ïãú
        if (!this.isGrounded && this.velocity.y > 0) {
            return;
        }
        
        if (this.isGrounded && !this.isCrouching && (this.velocity.x !== 0 || this.velocity.z !== 0)) {
            this.cameraBobTimer += deltaTime * this.cameraBobSpeed * 
                                   (this.isRunning ? 1.5 : 1);
            const bobOffset = Math.sin(this.cameraBobTimer) * this.cameraBobAmount;
            const baseY = this.isCrouching ? this.originalCameraY * 0.5 : this.originalCameraY;
            this.camera.position.y = baseY + bobOffset;
        } else {
            this.cameraBobTimer = 0;
            if (!this.isCrouching && this.isGrounded) {
                this.camera.position.y = this.originalCameraY;
            }
        }
    }
    
    takeDamage(amount) {
        this.currentHealth = Math.max(0, this.currentHealth - amount);
        if (this.onHealthChanged) {
            this.onHealthChanged(this.currentHealth, this.maxHealth);
        }
        
        if (this.currentHealth <= 0) {
            this.die();
        }
    }
    
    heal(amount) {
        this.currentHealth = Math.min(this.maxHealth, this.currentHealth + amount);
        if (this.onHealthChanged) {
            this.onHealthChanged(this.currentHealth, this.maxHealth);
        }
    }
    
    addSugar(amount) {
        this.sugarMeter = Math.min(this.maxSugarMeter, this.sugarMeter + amount);
    }
    
    activateSugarRush() {
        if (this.sugarMeter >= this.maxSugarMeter) {
            if (this.onSugarRushToggle) {
                this.onSugarRushToggle(true);
            }
            this.sugarMeter = 0;
            setTimeout(() => {
                if (this.onSugarRushToggle) {
                    this.onSugarRushToggle(false);
                }
            }, 5000);
        }
    }
    
    die() {
    }
    
    getPosition() {
        return this.camera.position.clone();
    }
    
    getForwardDirection() {
        const direction = new THREE.Vector3();
        this.camera.getWorldDirection(direction);
        return direction;
    }
}

// PowerUp
class PowerUp {
    constructor(scene, position, type) {
        this.scene = scene;
        this.position = position.clone();
        this.type = type; // 'health', 'ammo', 'speed', 'damage'
        this.collected = false;
        this.createMesh();
    }
    
    createMesh() {
        const colors = {
            'health': 0xff69b4,
            'ammo': 0x4169e1,
            'speed': 0x00ff00,
            'damage': 0xff0000
        };
        
        const geometry = new THREE.SphereGeometry(0.3, 8, 8);
        const material = new THREE.MeshStandardMaterial({ 
            color: colors[this.type] || 0xffffff,
            emissive: colors[this.type] || 0xffffff,
            emissiveIntensity: 0.5
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(this.position);
        this.mesh.position.y += 0.3;
        this.scene.add(this.mesh);
    }
    
    update(deltaTime) {
        if (this.collected) return;
        this.mesh.rotation.y += deltaTime * 2;
        this.mesh.position.y = this.position.y + 0.3 + Math.sin(Date.now() * 0.003) * 0.2;
    }
    
    checkCollection(playerPos) {
        if (this.collected) return false;
        const distance = this.position.distanceTo(playerPos);
        if (distance < 1.5) { // ÏàòÏßë Í±∞Î¶¨ Ï¶ùÍ∞Ä
            this.collect();
            return true;
        }
        return false;
    }
    
    collect() {
        this.collected = true;
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
    }
}

// Tower - Ï§ëÏïô ÎèÑÌÜ†Î¶¨ ÌÉÄÏõå
class Tower {
    constructor(scene, position) {
        this.scene = scene;
        this.position = position.clone();
        this.maxHealth = 1000;
        this.currentHealth = this.maxHealth;
        this.isDestroyed = false;
        
        this.mesh = null;
        this.createMesh();
        
        this.onDestroyed = null;
        this.onHealthChanged = null;
    }
    
    createMesh() {
        // Í±∞ÎåÄÌïú ÎèÑÌÜ†Î¶¨ ÌÉÄÏõå
        const towerGroup = new THREE.Group();
        
        // ÎèÑÌÜ†Î¶¨ Î™∏Ï≤¥ (ÏïÑÎûòÏ™ΩÏù¥ ÎÑìÏùÄ ÏõêÌÜµ)
        const bodyGeometry = new THREE.CylinderGeometry(3.5, 4.5, 10, 12);
        const bodyMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513, // Í∞àÏÉâ
            roughness: 0.9,
            metalness: 0.1
        });
        const towerBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
        towerBody.position.set(0, 5, 0);
        towerBody.castShadow = true;
        towerBody.receiveShadow = true;
        towerGroup.add(towerBody);
        
        // ÎèÑÌÜ†Î¶¨ Ï§ëÍ∞Ñ Î∂ÄÎ∂Ñ (Íµ¨)
        const middleGeometry = new THREE.SphereGeometry(3.2, 12, 12);
        const middleMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513,
            roughness: 0.9
        });
        const middle = new THREE.Mesh(middleGeometry, middleMaterial);
        middle.position.set(0, 10.5, 0);
        middle.scale.set(1, 1.3, 1);
        middle.castShadow = true;
        towerGroup.add(middle);
        
        // ÎèÑÌÜ†Î¶¨ ÎöúÍªë (Ïñ¥ÎëêÏö¥ Í∞àÏÉâ ÏõêÎøî)
        const capGeometry = new THREE.ConeGeometry(2.5, 2, 12);
        const capMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x654321, // Ïñ¥ÎëêÏö¥ Í∞àÏÉâ
            roughness: 0.8
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.set(0, 12.5, 0);
        cap.castShadow = true;
        towerGroup.add(cap);
        
        // ÎèÑÌÜ†Î¶¨ Ï§ÑÍ∏∞ (ÏûëÏùÄ ÏõêÎøî)
        const stemGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
        const stemMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a4a2a,
            roughness: 0.7
        });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.set(0, 13.8, 0);
        towerGroup.add(stem);
        
        // Ïû•ÏãùÏö© ÏûëÏùÄ ÎèÑÌÜ†Î¶¨Îì§ (ÌÉÄÏõå Ï£ºÎ≥Ä)
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const smallAcornGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const smallAcornMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x9b5a2a,
                roughness: 0.9
            });
            const smallAcorn = new THREE.Mesh(smallAcornGeometry, smallAcornMaterial);
            smallAcorn.position.set(
                Math.cos(angle) * 4.5,
                3 + Math.sin(i) * 2,
                Math.sin(angle) * 4.5
            );
            smallAcorn.scale.set(1, 1.2, 1);
            towerGroup.add(smallAcorn);
            
            // ÏûëÏùÄ ÎèÑÌÜ†Î¶¨ ÎöúÍªë
            const smallCap = new THREE.Mesh(
                new THREE.ConeGeometry(0.3, 0.3, 8),
                new THREE.MeshStandardMaterial({ color: 0x654321 })
            );
            smallCap.position.copy(smallAcorn.position);
            smallCap.position.y += 0.5;
            towerGroup.add(smallCap);
        }
        
        towerGroup.position.copy(this.position);
        this.mesh = towerGroup;
        this.scene.add(this.mesh);
    }
    
    takeDamage(amount) {
        if (this.isDestroyed) return;
        
        this.currentHealth -= amount;
        if (this.currentHealth < 0) this.currentHealth = 0;
        
        if (this.onHealthChanged) {
            this.onHealthChanged(this.currentHealth, this.maxHealth);
        }
        
        // ÌÉÄÏõå ÌååÍ¥¥ Ï≤¥ÌÅ¨
        if (this.currentHealth <= 0 && !this.isDestroyed) {
            this.destroy();
        }
    }
    
    destroy() {
        if (this.isDestroyed) return;
        this.isDestroyed = true;
        
        // ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò - ÌÉÄÏõåÍ∞Ä Î¨¥ÎÑàÏßÄÎäî Ìö®Í≥º
        if (this.mesh && this.mesh.children) {
            let animationFrame = 0;
            const destroyAnimation = () => {
                if (animationFrame++ > 100) return; // 100ÌîÑÎ†àÏûÑ ÌõÑ Ï¢ÖÎ£å
                
                this.mesh.children.forEach((child) => {
                    if (child.position) {
                        child.position.y -= 0.05;
                        child.rotation.x += 0.02;
                        child.rotation.z += 0.02;
                    }
                });
                
                if (animationFrame < 100) {
                    requestAnimationFrame(destroyAnimation);
                }
            };
            destroyAnimation();
        }
        
        if (this.onDestroyed) {
            this.onDestroyed();
        }
    }
    
    getPosition() {
        return this.position.clone();
    }
}

// TurretBase - Ìè¨ÌÉë Í∏∞Î≥∏ ÌÅ¥ÎûòÏä§
class TurretBase {
    constructor(scene, position, type = 'basic') {
        this.scene = scene;
        this.position = position.clone();
        this.type = type;
        this.fireTimer = 0;
        this.target = null;
        
        // ÌÉÄÏûÖÎ≥Ñ Ïä§ÌÉØ ÏÑ§Ï†ï
        this.setStats(type);
        
        this.mesh = null;
        this.createMesh();
    }
    
    setStats(type) {
        switch(type) {
            case 'basic':
                this.range = 15;
                this.damage = 20;
                this.fireRate = 1.0;
                this.cost = 150;
                break;
            case 'rapid':
                this.range = 12;
                this.damage = 15;
                this.fireRate = 2.5; // Îπ†Î•∏ Î∞úÏÇ¨
                this.cost = 200;
                break;
            case 'heavy':
                this.range = 18;
                this.damage = 40;
                this.fireRate = 0.6; // ÎäêÎ¶∞ Î∞úÏÇ¨, Í∞ïÌïú Îç∞ÎØ∏ÏßÄ
                this.cost = 300;
                break;
            case 'sniper':
                this.range = 25;
                this.damage = 50;
                this.fireRate = 0.8;
                this.cost = 350;
                break;
            case 'splash':
                this.range = 14;
                this.damage = 25;
                this.fireRate = 1.2;
                this.splashRadius = 3; // Î≤îÏúÑ Îç∞ÎØ∏ÏßÄ
                this.cost = 400;
                break;
            default:
                this.range = 15;
                this.damage = 20;
                this.fireRate = 1.0;
                this.cost = 150;
        }
    }
    
    createMesh() {
        const turretGroup = new THREE.Group();
        
        // ÎèÑÌÜ†Î¶¨ Í∏∞Îë• (Í∞àÏÉâ ÏõêÌÜµ)
        const baseGeometry = new THREE.CylinderGeometry(0.5, 0.6, 1.5, 8);
        const baseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513, // Í∞àÏÉâ
            roughness: 0.9
        });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.75;
        base.castShadow = true;
        base.receiveShadow = true;
        turretGroup.add(base);
        
        // ÎèÑÌÜ†Î¶¨ Î™∏Ï≤¥ (Í∞àÏÉâ Íµ¨)
        const bodyGeometry = new THREE.SphereGeometry(0.6, 8, 8);
        const bodyMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513,
            roughness: 0.9
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.8;
        body.scale.set(1, 1.2, 1);
        body.castShadow = true;
        turretGroup.add(body);
        
        // ÎèÑÌÜ†Î¶¨ ÎöúÍªë (Ïñ¥ÎëêÏö¥ Í∞àÏÉâ ÏõêÎøî)
        const capGeometry = new THREE.ConeGeometry(0.5, 0.4, 8);
        const capMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x654321,
            roughness: 0.8
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.y = 2.4;
        cap.castShadow = true;
        turretGroup.add(cap);
        
        // Ìè¨Íµ¨ (ÎèÑÌÜ†Î¶¨ÏóêÏÑú ÎÇòÏò§Îäî Ï¥ùÏïå)
        const barrelGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.8, 6);
        const barrelMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x654321,
            roughness: 0.7
        });
        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
        barrel.position.set(0, 1.8, 0.6);
        barrel.rotation.x = Math.PI / 2;
        turretGroup.add(barrel);
        
        // ÌÉÄÏûÖÎ≥Ñ ÌäπÏàò Ìö®Í≥º
        if (this.type === 'rapid') {
            // Îπ†Î•∏ Ìè¨ÌÉë - ÏûëÏùÄ ÎèÑÌÜ†Î¶¨ Ï∂îÍ∞Ä
            const smallAcorn = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 6, 6),
                new THREE.MeshStandardMaterial({ color: 0x9b5a2a })
            );
            smallAcorn.position.set(0.3, 1.5, 0);
            turretGroup.add(smallAcorn);
        } else if (this.type === 'heavy') {
            // Í∞ïÎ†•Ìïú Ìè¨ÌÉë - ÌÅ∞ ÎèÑÌÜ†Î¶¨
            body.scale.set(1.3, 1.4, 1.3);
            base.scale.set(1.2, 1, 1.2);
        } else if (this.type === 'sniper') {
            // Ï†ÄÍ≤© Ìè¨ÌÉë - Í∏¥ Ìè¨Íµ¨
            barrel.scale.set(1, 1.5, 1);
            const scope = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8),
                new THREE.MeshStandardMaterial({ color: 0x2c2c2c })
            );
            scope.position.set(0, 2.2, 0.3);
            scope.rotation.x = Math.PI / 2;
            turretGroup.add(scope);
        } else if (this.type === 'splash') {
            // Î≤îÏúÑ Ìè¨ÌÉë - Ïó¨Îü¨ Ìè¨Íµ¨
            for (let i = 0; i < 3; i++) {
                const multiBarrel = barrel.clone();
                multiBarrel.position.set(
                    (i - 1) * 0.2,
                    1.8,
                    0.6
                );
                turretGroup.add(multiBarrel);
            }
        }
        
        turretGroup.position.copy(this.position);
        this.mesh = turretGroup;
        this.scene.add(this.mesh);
    }
    
    update(deltaTime, enemies) {
        this.fireTimer += deltaTime;
        
        // Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å Ï∞æÍ∏∞
        let closestEnemy = null;
        let closestDistance = this.range;
        
        enemies.forEach(enemy => {
            if (enemy.isDead) return;
            const distance = this.position.distanceTo(enemy.position);
            if (distance < closestDistance) {
                closestDistance = distance;
                closestEnemy = enemy;
            }
        });
        
        this.target = closestEnemy;
        
        // Ï†ÅÏùÑ Ìñ•Ìï¥ Ìè¨ÌÉë ÌöåÏ†Ñ
        if (this.target) {
            const direction = new THREE.Vector3()
                .subVectors(this.target.position, this.position)
                .normalize();
            const angle = Math.atan2(direction.x, direction.z);
            this.mesh.rotation.y = angle;
            
            // Î∞úÏÇ¨
            if (this.fireTimer >= 1.0 / this.fireRate) {
                this.fire(enemies);
                this.fireTimer = 0;
            }
        }
    }
    
    fire(enemies) {
        if (!this.target || this.target.isDead) return;
        
        // Í∏∞Î≥∏ Îç∞ÎØ∏ÏßÄ
        this.target.takeDamage(this.damage);
        
        // Î≤îÏúÑ Îç∞ÎØ∏ÏßÄ Ìè¨ÌÉëÏùò Í≤ΩÏö∞
        if (this.type === 'splash' && this.splashRadius) {
            enemies.forEach(enemy => {
                if (enemy.isDead || enemy === this.target) return;
                const distance = this.target.position.distanceTo(enemy.position);
                if (distance <= this.splashRadius) {
                    const splashDamage = this.damage * (1 - distance / this.splashRadius) * 0.5;
                    enemy.takeDamage(splashDamage);
                }
            });
        }
    }
    
    getCost() {
        return this.cost;
    }
    
    getTypeName() {
        const names = {
            'basic': 'Í∏∞Î≥∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'rapid': 'Îπ†Î•∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'heavy': 'Í∞ïÎ†•Ìïú ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'sniper': 'Ï†ÄÍ≤© ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'splash': 'Î≤îÏúÑ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë'
        };
        return names[this.type] || 'ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë';
    }
    
    dispose() {
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this.mesh.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        }
    }
}

// ResourceManager - Î¶¨ÏÜåÏä§ Í¥ÄÎ¶¨
class ResourceManager {
    constructor() {
        this.resources = 0;
        this.onResourceChanged = null;
    }
    
    addResources(amount) {
        this.resources += amount;
        if (this.onResourceChanged) {
            this.onResourceChanged(this.resources);
        }
    }
    
    spendResources(amount) {
        if (this.resources >= amount) {
            this.resources -= amount;
            if (this.onResourceChanged) {
                this.onResourceChanged(this.resources);
            }
            return true;
        }
        return false;
    }
    
    getResources() {
        return this.resources;
    }
}

// BossEnemy
class BossEnemy extends EnemyBase {
    constructor(scene, position, player = null) {
        super(scene, 'boss', position, player);
        this.maxHealth = 200;
        this.currentHealth = 200;
        this.speed = 2;
        this.attackRange = 20;
        this.attackDamage = 15;
        this.attackCooldown = 1;
        this.isBoss = true;
        this.phase = 1; // 1, 2, 3
    }
    
    createMesh() {
        // Í±∞ÎåÄÌïú Î≥¥Ïä§ Î™®Ïäµ
        const bodyGeometry = new THREE.SphereGeometry(1.5, 12, 12);
        const bodyMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b0000, // ÏßÑÌïú Îπ®Í∞ÑÏÉâ
            emissive: 0xff0000,
            emissiveIntensity: 0.3
        });
        this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
        this.mesh.scale.set(1, 1.2, 1);
        this.mesh.position.copy(this.position);
        this.mesh.position.y += 1.5;
        
        // Îàà
        const eyeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.5, 0.3, 1.2);
        this.mesh.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.5, 0.3, 1.2);
        this.mesh.add(rightEye);
        
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.scene.add(this.mesh);
    }
    
    takeDamage(amount, isHeadshot = false) {
        super.takeDamage(amount, isHeadshot);
        
        // ÌéòÏù¥Ï¶à Ï≤¥ÌÅ¨
        const healthPercent = this.currentHealth / this.maxHealth;
        if (healthPercent < 0.33 && this.phase === 1) {
            this.phase = 2;
            this.speed *= 1.5;
            this.attackCooldown *= 0.7;
        } else if (healthPercent < 0.66 && this.phase === 2) {
            this.phase = 3;
            this.speed *= 1.3;
            this.attackCooldown *= 0.8;
        }
    }
}

// Game
class Game {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        
        this.player = null;
        this.weaponManager = null;
        this.enemyManager = null;
        this.stageManager = null;
        this.uiManager = null;
        this.soundManager = null;
        this.inputManager = null;
        this.scoreManager = null;
        this.particleSystem = null;
        
        this.powerUps = [];
        this.currentWave = 0;
        this.bossSpawned = false;
        
        this.isPaused = false;
        this.isGameOver = false;
        
        // ÎîîÌéúÏä§ Í≤åÏûÑ ÏãúÏä§ÌÖú
        this.tower = null;
        this.turrets = [];
        this.resourceManager = null;
        
        // ÏÉàÎ°úÏö¥ ÏãúÏä§ÌÖú
        this.floatingDamageSystem = null;
        this.cameraShakeSystem = null;
        this.hitMarkerSystem = null;
        this.minimapSystem = null;
        this.shopSystem = null;
    }
    
    async init() {
        try {
            console.log('Î°úÎî© ÌôîÎ©¥ ÌëúÏãú...');
            this.showLoadingScreen();
            
            console.log('Ïî¨ Ï¥àÍ∏∞Ìôî...');
            this.initScene();
            
            console.log('Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî...');
            this.inputManager = new InputManager();
            this.soundManager = new SoundManager();
            this.uiManager = new UIManager();
            this.scoreManager = new ScoreManager();
            this.particleSystem = new ParticleSystem(this.scene);
            this.resourceManager = new ResourceManager();
            this.stageManager = new StageManager(this.scene);
            this.player = new PlayerController(this.camera, this.scene);
            this.weaponManager = new WeaponManager(this.camera, this.scene);
            this.enemyManager = new EnemyManager(this.scene);
            
            // ÏÉàÎ°úÏö¥ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
            this.floatingDamageSystem = new FloatingDamageSystem();
            this.cameraShakeSystem = new CameraShakeSystem(this.camera);
            this.hitMarkerSystem = new HitMarkerSystem();
            this.minimapSystem = new MinimapSystem(this.scene, this.camera, null, this.enemyManager.enemies);
            this.shopSystem = new ShopSystem(this);
            
            // ÌÉÄÏõå ÏÉùÏÑ± (Ï§ëÏïô)
            this.tower = new Tower(this.scene, new THREE.Vector3(0, 0, 0));
            this.tower.onDestroyed = () => {
                this.gameOver();
            };
            this.tower.onHealthChanged = (current, max) => {
                this.uiManager.updateTowerHealth(current, max);
            };
            
            // ÎØ∏ÎãàÎßµÏóê ÌÉÄÏõå Ï∞∏Ï°∞ ÏÑ§Ï†ï
            this.minimapSystem.tower = this.tower;
            
            console.log('Ïä§ÌÖåÏù¥ÏßÄ Î°úÎìú...');
            await this.stageManager.loadStage('mossyMeadow');
            
            console.log('Ïù¥Î≤§Ìä∏ Ïó∞Í≤∞...');
            this.setupEventListeners();
            
            // Ï∂©Îèå Í∞ÄÎä•Ìïú Ïò§Î∏åÏ†ùÌä∏ ÏàòÏßë - ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ (Ïî¨Ïù¥ ÏôÑÏ†ÑÌûà Î°úÎìúÎêú ÌõÑ)
            setTimeout(() => {
            const collidableObjects = [];
            this.scene.traverse((object) => {
                if (object.isMesh && object !== this.camera && 
                    (object.geometry.type === 'BoxGeometry' || 
                     object.geometry.type === 'CylinderGeometry' || 
                     object.geometry.type === 'ConeGeometry' ||
                     object.geometry.type === 'DodecahedronGeometry')) {
                    // Î≤ΩÍ≥º ÎÇòÎ¨¥Îßå Ï∂©Îèå Ï≤¥ÌÅ¨ (ÌíÄ, ÍΩÉ, Î∞îÎã• Ï†úÏô∏)
                    if (object.material && object.material.color && object.geometry.type !== 'PlaneGeometry') {
                        const color = object.material.color.getHex();
                        // ÎÇòÎ¨¥(Í∞àÏÉâ), Î≤Ω(Í∞àÏÉâ), Îèå(ÌöåÏÉâ)Îßå Ï∂©Îèå
                        if (color === 0x6b4423 || color === 0x8b4513 || color === 0x757575 || 
                            (color >= 0x6b0000 && color <= 0x8b8000 && object.geometry.type !== 'PlaneGeometry')) {
                            // ÏûëÏùÄ Ïò§Î∏åÏ†ùÌä∏(ÌíÄ, ÍΩÉ)Îäî Ï†úÏô∏
                            const scale = object.scale || {x: 1, y: 1, z: 1};
                            const size = Math.max(
                                (object.geometry.parameters?.width || 0) * scale.x,
                                (object.geometry.parameters?.height || 0) * scale.y,
                                (object.geometry.parameters?.depth || 0) * scale.z,
                                (object.geometry.parameters?.radius || 0) * scale.x,
                                (object.geometry.parameters?.radiusTop || 0) * scale.x
                            );
                            if (size > 0.3) { // ÎÇòÎ¨¥ÏôÄ Î≤Ω Ìè¨Ìï®
                                collidableObjects.push(object);
                            }
                        }
                    }
                }
            });
                console.log('Collidable objects:', collidableObjects.length);
                this.player.setCollidableObjects(collidableObjects);
            }, 200);
            
            // Ï¥àÍ∏∞ UI ÏóÖÎç∞Ïù¥Ìä∏
            this.uiManager.updateHealth(this.player.currentHealth, this.player.maxHealth);
            this.uiManager.updateAmmo(this.weaponManager.currentWeapon.currentAmmo, this.weaponManager.currentWeapon.maxAmmo);
            this.uiManager.updateSugarMeter(this.player.sugarMeter, this.player.maxSugarMeter);
            this.uiManager.updateScore(this.scoreManager.score);
            
            // ÌÉÄÏõå Ï≤¥Î†• Ï¥àÍ∏∞ ÌëúÏãú
            if (this.tower) {
                this.uiManager.updateTowerHealth(this.tower.currentHealth, this.tower.maxHealth);
            }
            
            console.log('Î°úÎî© ÏôÑÎ£å, Î©îÏù∏ Î©îÎâ¥ ÌëúÏãú...');
            this.hideLoadingScreen();
            this.showMainMenu();
            
            console.log('Í≤åÏûÑ Î£®ÌîÑ ÏãúÏûë...');
            this.animate();
        } catch (error) {
            console.error('Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•ò:', error);
            this.hideLoadingScreen();
            alert('Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
            // ÏóêÎü¨Î•º Îã§Ïãú throwÌïòÏó¨ PromiseÍ∞Ä rejectÎêòÎèÑÎ°ù Ìï®
            throw error;
        }
    }
    
    initScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87CEEB); // ÌïòÎäòÏÉâ (Î∞∞Í≤ΩÎßå)
        this.scene.fog = new THREE.Fog(0x87CEEB, 50, 300);
        
        this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        // ÌöåÏ†Ñ ÏàúÏÑúÎ•º YXZÎ°ú ÏÑ§Ï†ïÌïòÏó¨ ÏàòÌèâ/ÏàòÏßÅ ÌöåÏ†Ñ ÏôÑÏ†ÑÌûà Î∂ÑÎ¶¨
        this.camera.rotation.order = 'YXZ';
        this.camera.position.set(0, 1.6, 5);
        
        this.renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('gameCanvas'),
            antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        this.scene.add(directionalLight);
        
        window.addEventListener('resize', () => this.onWindowResize());
    }
    
    setupEventListeners() {
        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Ï†Ñ Ï≤¥Î†• Ï∂îÏ†Å (Îç∞ÎØ∏ÏßÄ Ï†ÑÎã¨ Î∞©ÏßÄ)
        this.playerPreviousHealth = this.player.maxHealth;
        
        this.player.onHealthChanged = (current, max) => {
            this.uiManager.updateHealth(current, max);
            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Îç∞ÎØ∏ÏßÄÎ•º Î∞õÏúºÎ©¥ ÌÉÄÏõå Ï≤¥Î†•ÎèÑ ÏùºÎ∂Ä Í∞êÏÜå (Îç∞ÎØ∏ÏßÄÎßå, Ìûê Ï†úÏô∏)
            if (current < this.playerPreviousHealth && this.tower && !this.tower.isDestroyed) {
                const damageTaken = this.playerPreviousHealth - current;
                // Ïã§Ï†úÎ°ú Îç∞ÎØ∏ÏßÄÎ•º Î∞õÏïòÏùÑ ÎïåÎßå ÌÉÄÏõåÏóê Ï†ÑÎã¨
                if (damageTaken > 0) {
                    const towerDamage = damageTaken * 0.1; // ÌîåÎ†àÏù¥Ïñ¥ Îç∞ÎØ∏ÏßÄÏùò 10%Î•º ÌÉÄÏõåÏóê Ï†ÑÎã¨
                    this.tower.takeDamage(towerDamage);
                    // ÌîåÎ†àÏù¥Ïñ¥ ÌîºÍ≤© Ïãú Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
                    if (this.cameraShakeSystem) {
                        this.cameraShakeSystem.shake(0.15, 0.3);
                    }
                }
            }
            this.playerPreviousHealth = current;
        };
        
        this.player.onSugarRushToggle = (active) => {
            this.uiManager.toggleSugarRushOverlay(active);
            if (active) {
                this.soundManager.play('sugarRush');
            }
        };
        
        this.weaponManager.onAmmoChanged = (current, max) => {
            this.uiManager.updateAmmo(current, max);
        };
        
        this.weaponManager.onWeaponChanged = (weapon) => {
            this.uiManager.updateWeaponName(weapon.name);
        };
        
        // Ï†ÅÏù¥ ÌÉÄÏõåÎ•º ÌÉÄÍ≤üÏúºÎ°ú ÏÑ§Ï†ï
        this.enemyManager.setTowerTarget = (tower) => {
            this.enemyManager.enemies.forEach(enemy => {
                enemy.setTowerTarget(tower);
            });
        };
        
        // ÏÉà Ï†Å Ïä§Ìè∞ Ïãú ÌÉÄÏõå ÌÉÄÍ≤ü ÏÑ§Ï†ï
        const originalSpawnEnemy = this.enemyManager.spawnEnemy.bind(this.enemyManager);
        this.enemyManager.spawnEnemy = (type, position, player, playerController) => {
            const enemy = originalSpawnEnemy(type, position, player, playerController);
            if (this.tower) {
                enemy.setTowerTarget(this.tower);
            }
            return enemy;
        };
        
        this.enemyManager.onEnemyKilled = (enemy, isHeadshot = false) => {
            // Î¶¨ÏÜåÏä§ ÌöçÎìù
            if (this.resourceManager) {
                this.resourceManager.addResources(enemy.resourceValue || 10);
            }
            this.player.addSugar(10);
            this.uiManager.updateSugarMeter(this.player.sugarMeter, this.player.maxSugarMeter);
            
            // Ï†êÏàò Ï∂îÍ∞Ä
            const baseScore = enemy.isBoss ? 500 : 100;
            const scoreResult = this.scoreManager.addScore(baseScore, isHeadshot);
            this.uiManager.updateScore(this.scoreManager.score);
            this.uiManager.updateCombo(scoreResult.combo, scoreResult.isHeadshot);
            
            // ÌååÌã∞ÌÅ¥ Ìö®Í≥º
            if (enemy.mesh) {
                const color = enemy.isBoss ? 0xff0000 : 0xff6b6b;
                this.particleSystem.createExplosion(enemy.mesh.position, color, enemy.isBoss ? 50 : 20);
            }
            
            // Î≥¥Ïä§ Ï≤òÏπò Ïãú ÌååÏõåÏóÖ ÎìúÎ°≠
            if (enemy.isBoss) {
                this.spawnPowerUps(enemy.mesh.position, 3);
            } else if (Math.random() < 0.2) { // 20% ÌôïÎ•†Î°ú ÌååÏõåÏóÖ ÎìúÎ°≠
                const types = ['health', 'ammo', 'speed', 'damage'];
                const type = types[Math.floor(Math.random() * types.length)];
                this.spawnPowerUp(enemy.mesh.position, type);
            }
        };
        
        this.stageManager.onStageChanged = (stageName) => {
            this.uiManager.showStageTitle(stageName);
            this.soundManager.playStageMusic(stageName);
        };
        
        // Ï†ÅÏù¥ ÌîåÎ†àÏù¥Ïñ¥Î•º Ï∞æÎèÑÎ°ù ÏÑ§Ï†ï
        this.enemyManager.setPlayer(this.player);
        this.weaponManager.setEnemyManager(this.enemyManager);
        this.weaponManager.setParticleSystem(this.particleSystem);
        
        // Ïõ®Ïù¥Î∏å ÏãúÏûë ÏΩúÎ∞±
        this.enemyManager.onWaveStart = (wave) => {
            this.currentWave = wave;
            console.log('Ïõ®Ïù¥Î∏å ÏãúÏûë:', wave);
            // 5Ïõ®Ïù¥Î∏åÎßàÎã§ Î≥¥Ïä§ Ïä§Ìè∞ Î¶¨ÏÖã Î∞è Ï≤¥ÌÅ¨
            if (wave % 5 === 0) {
                this.bossSpawned = false;
                // Î≥¥Ïä§ Ïä§Ìè∞ Ï≤¥ÌÅ¨
                this.checkBossSpawn();
            }
        };
        
        // Ïõ®Ïù¥Î∏å ÏôÑÎ£å ÏΩúÎ∞±
        this.enemyManager.onWaveComplete = () => {
            this.onWaveComplete();
            // ÏÉÅÏ†êÏùÄ B ÌÇ§Î°úÎßå Ïó¥ Ïàò ÏûàÏùå (ÏûêÎèô Ïò§Ìîà Ï†úÍ±∞)
        };
        
        // Î™®Îì† Ï†ÅÏù¥ ÌÉÄÏõåÎ•º ÌÉÄÍ≤üÏúºÎ°ú ÏÑ§Ï†ï
        if (this.tower) {
            this.enemyManager.enemies.forEach(enemy => {
                enemy.setTowerTarget(this.tower);
            });
        }
        
        // Î¶¨ÏÜåÏä§ Î≥ÄÍ≤Ω Ïãú UI ÏóÖÎç∞Ïù¥Ìä∏
        this.resourceManager.onResourceChanged = (resources) => {
            this.uiManager.updateResources(resources);
        };
        
        // Ï¥àÍ∏∞ Î¶¨ÏÜåÏä§ ÌëúÏãú
        this.uiManager.updateResources(0);
        
        // Í≤åÏûÑ Ïù∏Ïä§ÌÑ¥Ïä§Î•º Ï†ÑÏó≠ÏúºÎ°ú ÏÑ§Ï†ï (ÌîåÎ°úÌåÖ Îç∞ÎØ∏ÏßÄ ÏãúÏä§ÌÖúÏóêÏÑú Ï†ëÍ∑ºÌïòÍ∏∞ ÏúÑÌï¥)
        window.game = this;
        
        // T ÌÇ§Î°ú Ìè¨ÌÉë ÏÑ§Ïπò
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyT' && !this.isPaused && !this.isGameOver) {
                e.preventDefault();
                this.placeTurret();
            }
            // B ÌÇ§Î°ú ÏÉÅÏ†ê Ïó¥Í∏∞/Îã´Í∏∞
            if (e.code === 'KeyB' && !this.isGameOver) {
                e.preventDefault();
                if (this.shopSystem) {
                    if (this.shopSystem.shopMenu.classList.contains('hidden')) {
                        // ÏÉÅÏ†ê Ïó¥Í∏∞
                        this.isPaused = true;
                        this.shopSystem.show();
                    } else {
                        // ÏÉÅÏ†ê Îã´Í∏∞
                        this.shopSystem.hide();
                        this.isPaused = false;
                    }
                }
            }
        });
        
        // ÏÉÅÏ†ê Îã´Í∏∞ Î≤ÑÌäº
        if (this.shopSystem) {
            this.shopSystem.closeShopBtn.addEventListener('click', () => {
                this.shopSystem.hide();
                this.isPaused = false;
            });
        }
    }
    
    placeTurret(type = 'basic') {
        // Ìè¨ÌÉë ÌÉÄÏûÖÎ≥Ñ ÎπÑÏö©
        const turretCosts = {
            'basic': 150,
            'rapid': 200,
            'heavy': 300,
            'sniper': 350,
            'splash': 400
        };
        
        const turretCost = turretCosts[type] || 150;
        
        if (!this.resourceManager.spendResources(turretCost)) {
            // Î¶¨ÏÜåÏä§ Î∂ÄÏ°±
            this.uiManager.showStageTitle('Î¶¨ÏÜåÏä§ Î∂ÄÏ°±! (ÌïÑÏöî: ' + turretCost + ')');
            return;
        }
        
        // ÌîåÎ†àÏù¥Ïñ¥ ÏïûÏóê Ìè¨ÌÉë ÏÑ§Ïπò
        const camera = this.camera;
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();
        
        const turretPosition = camera.position.clone();
        turretPosition.add(direction.multiplyScalar(5));
        turretPosition.y = 0;
        
        // Ìè¨ÌÉë ÏÉùÏÑ±
        const turret = new TurretBase(this.scene, turretPosition, type);
        this.turrets.push(turret);
        
        const typeNames = {
            'basic': 'Í∏∞Î≥∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'rapid': 'Îπ†Î•∏ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'heavy': 'Í∞ïÎ†•Ìïú ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'sniper': 'Ï†ÄÍ≤© ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë',
            'splash': 'Î≤îÏúÑ ÎèÑÌÜ†Î¶¨ Ìè¨ÌÉë'
        };
        
        this.uiManager.showStageTitle(typeNames[type] + ' ÏÑ§Ïπò ÏôÑÎ£å!');
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        
        if (this.isPaused || this.isGameOver) return;
        
        const deltaTime = this.clock.getDelta();
        
        this.player.update(deltaTime);
        this.weaponManager.update(deltaTime);
        this.enemyManager.update(deltaTime);
        this.stageManager.update(deltaTime);
        this.scoreManager.update(deltaTime);
        this.particleSystem.update(deltaTime);
        
        // Ìè¨ÌÉë ÏóÖÎç∞Ïù¥Ìä∏
        this.turrets.forEach(turret => {
            turret.update(deltaTime, this.enemyManager.enemies);
        });
        
        // ÌååÏõåÏóÖ ÏóÖÎç∞Ïù¥Ìä∏
        this.updatePowerUps(deltaTime);
        
        // Î≥¥Ïä§ Ï≤¥Î†•Î∞î ÏóÖÎç∞Ïù¥Ìä∏
        this.updateBossHealth();
        
        // ÏÉàÎ°úÏö¥ ÏãúÏä§ÌÖú ÏóÖÎç∞Ïù¥Ìä∏
        if (this.cameraShakeSystem) {
            this.cameraShakeSystem.update(deltaTime);
        }
        if (this.minimapSystem) {
            this.minimapSystem.enemies = this.enemyManager.enemies;
            this.minimapSystem.update();
        }
        
        // Î≥¥Ïä§ Ïä§Ìè∞ Ï≤¥ÌÅ¨Îäî onWaveStartÏóêÏÑúÎßå ÏàòÌñâ
        
        this.renderer.render(this.scene, this.camera);
    }
    
    updatePowerUps(deltaTime) {
        const playerPos = this.player.getPosition();
        for (let i = this.powerUps.length - 1; i >= 0; i--) {
            const powerUp = this.powerUps[i];
            powerUp.update(deltaTime);
            
            if (powerUp && !powerUp.collected && powerUp.checkCollection(playerPos)) {
                console.log('ÌååÏõåÏóÖ ÏàòÏßë:', powerUp.type);
                this.applyPowerUp(powerUp.type);
                this.powerUps.splice(i, 1);
                this.uiManager.showStageTitle('ÌååÏõåÏóÖ ÌöçÎìù: ' + powerUp.type);
            }
        }
    }
    
    applyPowerUp(type) {
        switch(type) {
            case 'health':
                this.player.heal(50);
                break;
            case 'ammo':
                if (this.weaponManager.currentWeapon) {
                    this.weaponManager.currentWeapon.currentAmmo = this.weaponManager.currentWeapon.maxAmmo;
                    this.uiManager.updateAmmo(this.weaponManager.currentWeapon.currentAmmo, this.weaponManager.currentWeapon.maxAmmo);
                }
                break;
            case 'speed':
                this.player.speed *= 1.5;
                this.player.runSpeed *= 1.5;
                setTimeout(() => {
                    this.player.speed /= 1.5;
                    this.player.runSpeed /= 1.5;
                }, 10000); // 10Ï¥à ÏßÄÏÜç
                break;
            case 'damage':
                if (this.weaponManager.currentWeapon) {
                    this.weaponManager.currentWeapon.damage *= 2;
                    setTimeout(() => {
                        this.weaponManager.currentWeapon.damage /= 2;
                    }, 10000); // 10Ï¥à ÏßÄÏÜç
                }
                break;
        }
    }
    
    spawnPowerUp(position, type) {
        const powerUp = new PowerUp(this.scene, position, type);
        this.powerUps.push(powerUp);
    }
    
    spawnPowerUps(position, count) {
        const types = ['health', 'ammo', 'speed', 'damage'];
        for (let i = 0; i < count; i++) {
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 3,
                0,
                (Math.random() - 0.5) * 3
            );
            const spawnPos = position.clone().add(offset);
            const type = types[Math.floor(Math.random() * types.length)];
            this.spawnPowerUp(spawnPos, type);
        }
    }
    
    updateBossHealth() {
        const boss = this.enemyManager.enemies.find(e => e.isBoss);
        if (boss) {
            this.uiManager.showBossHealth(boss.currentHealth, boss.maxHealth);
        } else {
            this.uiManager.hideBossHealth();
        }
    }
    
    checkBossSpawn() {
        if (this.bossSpawned) return;
        
        // 5Ïõ®Ïù¥Î∏åÎßàÎã§ Î≥¥Ïä§ Ïä§Ìè∞ (Ïõ®Ïù¥Î∏å ÏãúÏûë Ïãú)
        if (this.currentWave > 0 && this.currentWave % 5 === 0) {
            const spawnPoint = this.enemyManager.getRandomSpawnPoint();
            const boss = this.enemyManager.spawnEnemy('boss', spawnPoint, this.player.camera, this.player);
            if (boss) {
                this.bossSpawned = true;
                this.uiManager.showStageTitle('BOSS APPEARED!');
                console.log('Î≥¥Ïä§ Ïä§Ìè∞:', this.currentWave, 'Ïõ®Ïù¥Î∏å');
            }
        }
    }
    
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    showLoadingScreen() {
        document.getElementById('loadingScreen').classList.remove('hidden');
    }
    
    hideLoadingScreen() {
        document.getElementById('loadingScreen').classList.add('hidden');
    }
    
    showMainMenu() {
        document.getElementById('mainMenu').classList.remove('hidden');
        document.getElementById('startButton').addEventListener('click', () => {
            this.startGame();
        });
    }
    
    startGame() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('gameCanvas').style.cursor = 'none';
        
        // Ìè¨Ïù∏ÌÑ∞ Ïû†Í∏à ÏãúÎèÑ
        const canvas = document.getElementById('gameCanvas');
        canvas.requestPointerLock = canvas.requestPointerLock || 
                                   canvas.mozRequestPointerLock || 
                                   canvas.webkitRequestPointerLock;
        if (canvas.requestPointerLock) {
            canvas.requestPointerLock();
        }
        
        // Î™®Îì† Ï†ÅÏù¥ ÌÉÄÏõåÎ•º ÌÉÄÍ≤üÏúºÎ°ú ÏÑ§Ï†ï
        if (this.tower) {
            this.enemyManager.enemies.forEach(enemy => {
                enemy.setTowerTarget(this.tower);
            });
        }
        
        // Í≤åÏûÑ ÏãúÏûë Ïãú Ï≤´ Ïõ®Ïù¥Î∏å Ïä§Ìè∞
        this.enemyManager.startWave();
        this.currentWave = this.enemyManager.currentWave;
    }
    
    pause() {
        this.isPaused = true;
    }
    
    resume() {
        this.isPaused = false;
    }
    
    gameOver() {
        this.isGameOver = true;
        this.isPaused = true;
        
        // Í≤åÏûÑ Ïò§Î≤Ñ UI ÌëúÏãú
        const gameOverScreen = document.createElement('div');
        gameOverScreen.id = 'gameOverScreen';
        gameOverScreen.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; font-size: 48px;';
        gameOverScreen.innerHTML = `
            <div style="text-align: center;">
                <h1 style="font-size: 72px; margin-bottom: 20px; color: #ff0000;">GAME OVER</h1>
                <p style="font-size: 24px; margin-bottom: 20px;">ÎèÑÌÜ†Î¶¨ ÌÉÄÏõåÍ∞Ä ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§!</p>
                <p style="font-size: 20px; margin-bottom: 40px;">ÏµúÏ¢Ö Ï†êÏàò: ${this.scoreManager.score.toLocaleString()}</p>
                <p style="font-size: 18px; color: #ccc;">ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®ÌïòÏó¨ Îã§Ïãú ÏãúÏûëÌïòÏÑ∏Ïöî.</p>
            </div>
        `;
        document.body.appendChild(gameOverScreen);
    }
    
    onWaveComplete() {
        this.currentWave = this.enemyManager.currentWave;
        this.bossSpawned = false; // Î≥¥Ïä§ Ï≤òÏπò ÌõÑ Î¶¨ÏÖã
        // Îã§Ïùå Ïõ®Ïù¥Î∏åÎäî EnemyManagerÏóêÏÑú ÏûêÎèôÏúºÎ°ú ÏãúÏûëÎê®
    }
}

// Î©îÏù∏ Ï¥àÍ∏∞Ìôî
let game;

window.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('Í≤åÏûÑ Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
        game = new Game();
        try {
            await game.init();
        } catch (error) {
            console.error('Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error);
            alert('Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + (error.message || error));
        }
    } catch (error) {
        console.error('Í≤åÏûÑ ÏÉùÏÑ± Ïò§Î•ò:', error);
        alert('Í≤åÏûÑ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + (error.message || error));
    }
});
    </script>
</body>
</html>

